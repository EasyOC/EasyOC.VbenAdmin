/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.6.2.0 (NJsonSchema v10.1.23.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
import { AppServiceBase } from './app-service-base';

export class ApiServiceProxy extends AppServiceBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(instance?: AxiosInstance) {
    super();
    if (instance) {
      this.instance = instance;
    } else {
      this.instance = this.ajax;
    }
    this.baseUrl = '';
  }
  /**
   * @return Success
   */
  contentGet(contentItemId: string): Promise<void> {
    let url_ = this.baseUrl + '/api/content/{contentItemId}';
    if (contentItemId === undefined || contentItemId === null)
      throw new Error("The parameter 'contentItemId' must be defined.");
    url_ = url_.replace('{contentItemId}', encodeURIComponent('' + contentItemId));
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @return Success
   */
  contentDelete(contentItemId: string): Promise<void> {
    let url_ = this.baseUrl + '/api/content/{contentItemId}';
    if (contentItemId === undefined || contentItemId === null)
      throw new Error("The parameter 'contentItemId' must be defined.");
    url_ = url_.replace('{contentItemId}', encodeURIComponent('' + contentItemId));
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'DELETE',
      url: url_,
      headers: {},
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param draft (optional)
   * @param body (optional)
   * @return Success
   */
  contentPost(draft: boolean | undefined, body: ContentItem | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/content?';

    if (draft !== undefined && draft !== null)
      url_ += 'draft=' + encodeURIComponent('' + draft) + '&';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify(body);
    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param parameters (optional)
   * @return Success
   */
  queriesPost(name: string, parameters: string | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/queries/{name}?';
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace('{name}', encodeURIComponent('' + name));

    if (parameters !== undefined && parameters !== null)
      url_ += 'parameters=' + encodeURIComponent('' + parameters) + '&';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {},
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param parameters (optional)
   * @return Success
   */
  queriesGet(params: { name: string; parameters: string | undefined }): Promise<void> {
    const { name, parameters } = { ...params };

    let url_ = this.baseUrl + '/api/queries/{name}?';
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace('{name}', encodeURIComponent('' + name));

    if (parameters !== undefined && parameters !== null)
      url_ += 'parameters=' + encodeURIComponent('' + parameters) + '&';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }
}

export class LuceneServiceProxy extends AppServiceBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(instance?: AxiosInstance) {
    super();
    if (instance) {
      this.instance = instance;
    } else {
      this.instance = this.ajax;
    }
    this.baseUrl = '';
  }
  /**
   * @param indexName (optional)
   * @param query (optional)
   * @param parameters (optional)
   * @return Success
   */
  contentGet(params: {
    indexName: string | undefined;
    query: string | undefined;
    parameters: string | undefined;
  }): Promise<void> {
    const { indexName, query, parameters } = { ...params };

    let url_ = this.baseUrl + '/api/lucene/content?';

    if (indexName !== undefined && indexName !== null)
      url_ += 'IndexName=' + encodeURIComponent('' + indexName) + '&';

    if (query !== undefined && query !== null)
      url_ += 'Query=' + encodeURIComponent('' + query) + '&';

    if (parameters !== undefined && parameters !== null)
      url_ += 'Parameters=' + encodeURIComponent('' + parameters) + '&';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param body (optional)
   * @return Success
   */
  contentPost(body: LuceneQueryModel | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/lucene/content';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify(body);
    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param indexName (optional)
   * @param query (optional)
   * @param parameters (optional)
   * @return Success
   */
  documentsGet(params: {
    indexName: string | undefined;
    query: string | undefined;
    parameters: string | undefined;
  }): Promise<void> {
    const { indexName, query, parameters } = { ...params };

    let url_ = this.baseUrl + '/api/lucene/documents?';

    if (indexName !== undefined && indexName !== null)
      url_ += 'IndexName=' + encodeURIComponent('' + indexName) + '&';

    if (query !== undefined && query !== null)
      url_ += 'Query=' + encodeURIComponent('' + query) + '&';

    if (parameters !== undefined && parameters !== null)
      url_ += 'Parameters=' + encodeURIComponent('' + parameters) + '&';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param body (optional)
   * @return Success
   */
  documentsPost(body: LuceneQueryModel | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/lucene/documents';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify(body);
    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }
}

export class TenantsServiceProxy extends AppServiceBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(instance?: AxiosInstance) {
    super();
    if (instance) {
      this.instance = instance;
    } else {
      this.instance = this.ajax;
    }
    this.baseUrl = '';
  }
  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateApiViewModel | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/tenants/create';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify(body);
    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param body (optional)
   * @return Success
   */
  setup(body: SetupApiViewModel | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/tenants/setup';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify(body);
    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }
}

export class ContentManagementServiceProxy extends AppServiceBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(instance?: AxiosInstance) {
    super();
    if (instance) {
      this.instance = instance;
    } else {
      this.instance = this.ajax;
    }
    this.baseUrl = '';
  }
  /**
   * 列出所有类型定义
   * @param stereotype (optional)
   * @param filter (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @return Success
   */
  getAllTypes(params: {
    stereotype: string | undefined;
    filter: string | undefined;
    page: number | undefined;
    pageSize: number | undefined;
  }): Promise<PagedResultOfContentTypeListItemDto> {
    const { stereotype, filter, page, pageSize } = { ...params };

    let url_ = this.baseUrl + '/api/ContentManagement/GetAllTypes?';

    if (stereotype !== undefined && stereotype !== null)
      url_ += 'Stereotype=' + encodeURIComponent('' + stereotype) + '&';

    if (filter !== undefined && filter !== null)
      url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';

    if (page !== undefined && page !== null) url_ += 'Page=' + encodeURIComponent('' + page) + '&';

    if (pageSize !== undefined && pageSize !== null)
      url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param page (optional)
   * @param pageSize (optional)
   * @param filter (optional)
   * @return Success
   */
  getAllParts(params: {
    page: number | undefined;
    pageSize: number | undefined;
    filter: string | undefined;
  }): Promise<PagedResultOfContentPartDefinitionDto> {
    const { page, pageSize, filter } = { ...params };

    let url_ = this.baseUrl + '/api/ContentManagement/GetAllParts?';

    if (page !== undefined && page !== null) url_ += 'Page=' + encodeURIComponent('' + page) + '&';

    if (pageSize !== undefined && pageSize !== null)
      url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';

    if (filter !== undefined && filter !== null)
      url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param name (optional)
   * @param withSettings (optional)
   * @return Success
   */
  getPartDefinition(params: {
    name: string | undefined;
    withSettings: boolean | undefined;
  }): Promise<ContentPartDefinitionDto> {
    const { name, withSettings } = { ...params };

    let url_ = this.baseUrl + '/api/ContentManagement/GetPartDefinition?';

    if (name !== undefined && name !== null) url_ += 'name=' + encodeURIComponent('' + name) + '&';

    if (withSettings !== undefined && withSettings !== null)
      url_ += 'withSettings=' + encodeURIComponent('' + withSettings) + '&';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param name (optional)
   * @param withSettings (optional)
   * @return Success
   */
  getTypeDefinition(params: {
    name: string | undefined;
    withSettings: boolean | undefined;
  }): Promise<ContentTypeDefinitionDto> {
    const { name, withSettings } = { ...params };

    let url_ = this.baseUrl + '/api/ContentManagement/GetTypeDefinition?';

    if (name !== undefined && name !== null) url_ += 'name=' + encodeURIComponent('' + name) + '&';

    if (withSettings !== undefined && withSettings !== null)
      url_ += 'withSettings=' + encodeURIComponent('' + withSettings) + '&';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }
}

export class ExcelServiceProxy extends AppServiceBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(instance?: AxiosInstance) {
    super();
    if (instance) {
      this.instance = instance;
    } else {
      this.instance = this.ajax;
    }
    this.baseUrl = '';
  }
  /**
   * @param fileFullPath (optional)
   * @param rowFilterExpression (optional)
   * @return Success
   */
  getExcelDataFromConfig(params: {
    fileFullPath: string | undefined;
    rowFilterExpression: string | undefined;
  }): Promise<any> {
    const { fileFullPath, rowFilterExpression } = { ...params };

    let url_ = this.baseUrl + '/api/Excel/GetExcelDataFromConfig?';

    if (fileFullPath !== undefined && fileFullPath !== null)
      url_ += 'fileFullPath=' + encodeURIComponent('' + fileFullPath) + '&';

    if (rowFilterExpression !== undefined && rowFilterExpression !== null)
      url_ += 'rowFilterExpression=' + encodeURIComponent('' + rowFilterExpression) + '&';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param fileFullPath (optional)
   * @param configDocumentId (optional)
   * @param rowFilterExpression (optional)
   * @return Success
   */
  getProcessedData(params: {
    fileFullPath: string | undefined;
    configDocumentId: string | undefined;
    rowFilterExpression: string | undefined;
  }): Promise<any[]> {
    const { fileFullPath, configDocumentId, rowFilterExpression } = { ...params };

    let url_ = this.baseUrl + '/api/Excel/GetProcessedData?';

    if (fileFullPath !== undefined && fileFullPath !== null)
      url_ += 'fileFullPath=' + encodeURIComponent('' + fileFullPath) + '&';

    if (configDocumentId !== undefined && configDocumentId !== null)
      url_ += 'configDocumentId=' + encodeURIComponent('' + configDocumentId) + '&';

    if (rowFilterExpression !== undefined && rowFilterExpression !== null)
      url_ += 'rowFilterExpression=' + encodeURIComponent('' + rowFilterExpression) + '&';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @return Success
   */
  getAllExcelSettings(): Promise<SelectListItem[]> {
    let url_ = this.baseUrl + '/api/Excel/GetAllExcelSettings';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }
}

export class RDBMSServiceProxy extends AppServiceBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(instance?: AxiosInstance) {
    super();
    if (instance) {
      this.instance = instance;
    } else {
      this.instance = this.ajax;
    }
    this.baseUrl = '';
  }
  /**
   * Get all Connection Config
   * @return Success
   */
  getAllDbConnecton(): Promise<ConnectionConfigModel[]> {
    let url_ = this.baseUrl + '/api/RDBMS/GetAllDbConnecton';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * 根据连接设置获取指定数据库的表信息
   * @param connectionConfigId (optional)
   * @param disableCache (optional)
   * @param filterText (optional)
   * @param maxResultCount (optional)
   * @param skipCount (optional)
   * @return Success
   */
  getAllTables(params: {
    connectionConfigId: string | undefined;
    disableCache: boolean | undefined;
    filterText: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
  }): Promise<DbTableInfoDto[]> {
    const { connectionConfigId, disableCache, filterText, maxResultCount, skipCount } = {
      ...params,
    };

    let url_ = this.baseUrl + '/api/RDBMS/GetAllTables?';

    if (connectionConfigId !== undefined && connectionConfigId !== null)
      url_ += 'ConnectionConfigId=' + encodeURIComponent('' + connectionConfigId) + '&';

    if (disableCache !== undefined && disableCache !== null)
      url_ += 'DisableCache=' + encodeURIComponent('' + disableCache) + '&';

    if (filterText !== undefined && filterText !== null)
      url_ += 'FilterText=' + encodeURIComponent('' + filterText) + '&';

    if (maxResultCount !== undefined && maxResultCount !== null)
      url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';

    if (skipCount !== undefined && skipCount !== null)
      url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param connectionConfigId (optional)
   * @param tableName (optional) 表名，如：dbo.table1
   * @return Success
   */
  getTableDetails(params: {
    connectionConfigId: string | undefined;
    tableName: string | undefined;
  }): Promise<DbTableInfoDto> {
    const { connectionConfigId, tableName } = { ...params };

    let url_ = this.baseUrl + '/api/RDBMS/GetTableDetails?';

    if (connectionConfigId !== undefined && connectionConfigId !== null)
      url_ += 'connectionConfigId=' + encodeURIComponent('' + connectionConfigId) + '&';

    if (tableName !== undefined && tableName !== null)
      url_ += 'tableName=' + encodeURIComponent('' + tableName) + '&';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param connectionConfigId (optional)
   * @param tableName (optional)
   * @return Success
   */
  generateRecipe(params: {
    connectionConfigId: string | undefined;
    tableName: string | undefined;
  }): Promise<string> {
    const { connectionConfigId, tableName } = { ...params };

    let url_ = this.baseUrl + '/api/RDBMS/GenerateRecipe?';

    if (connectionConfigId !== undefined && connectionConfigId !== null)
      url_ += 'connectionConfigId=' + encodeURIComponent('' + connectionConfigId) + '&';

    if (tableName !== undefined && tableName !== null)
      url_ += 'tableName=' + encodeURIComponent('' + tableName) + '&';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @return Success
   */
  getAllOrchardCoreBaseFields(): Promise<OrchardCoreBaseField[]> {
    let url_ = this.baseUrl + '/api/RDBMS/GetAllOrchardCoreBaseFields';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * 使用JSON更新类型
   * @param body (optional)
   * @return Success
   */
  importDeploymentPackage(body: ImportJsonInupt | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/RDBMS/ImportDeploymentPackage';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify(body);
    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param id (optional)
   * @param configName (optional)
   * @param contentTypeName (optional)
   * @param connectionConfigId (optional)
   * @param targetTable (optional)
   * @param mappingData (optional)
   * @param readOnly (optional)
   * @param enableAutoSync (optional)
   * @return Success
   */
  getTableInfo(params: {
    id: string | undefined;
    configName: string | undefined;
    contentTypeName: string | undefined;
    syncMappingDeriction: SyncMappingDeriction;
    connectionConfigId: string | undefined;
    targetTable: string | undefined;
    mappingData: string | undefined;
    readOnly: boolean | undefined;
    enableAutoSync: boolean | undefined;
  }): Promise<any> {
    const {
      id,
      configName,
      contentTypeName,
      syncMappingDeriction,
      connectionConfigId,
      targetTable,
      mappingData,
      readOnly,
      enableAutoSync,
    } = { ...params };

    let url_ = this.baseUrl + '/api/RDBMS/GetTableInfo?';

    if (id !== undefined && id !== null) url_ += 'Id=' + encodeURIComponent('' + id) + '&';

    if (configName !== undefined && configName !== null)
      url_ += 'ConfigName=' + encodeURIComponent('' + configName) + '&';

    if (contentTypeName !== undefined && contentTypeName !== null)
      url_ += 'ContentTypeName=' + encodeURIComponent('' + contentTypeName) + '&';
    if (syncMappingDeriction === undefined || syncMappingDeriction === null)
      throw new Error("The parameter 'syncMappingDeriction' must be defined and cannot be null.");
    else url_ += 'SyncMappingDeriction=' + encodeURIComponent('' + syncMappingDeriction) + '&';

    if (connectionConfigId !== undefined && connectionConfigId !== null)
      url_ += 'ConnectionConfigId=' + encodeURIComponent('' + connectionConfigId) + '&';

    if (targetTable !== undefined && targetTable !== null)
      url_ += 'TargetTable=' + encodeURIComponent('' + targetTable) + '&';

    if (mappingData !== undefined && mappingData !== null)
      url_ += 'MappingData=' + encodeURIComponent('' + mappingData) + '&';

    if (readOnly !== undefined && readOnly !== null)
      url_ += 'ReadOnly=' + encodeURIComponent('' + readOnly) + '&';

    if (enableAutoSync !== undefined && enableAutoSync !== null)
      url_ += 'EnableAutoSync=' + encodeURIComponent('' + enableAutoSync) + '&';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }
}

export class RolesServiceProxy extends AppServiceBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(instance?: AxiosInstance) {
    super();
    if (instance) {
      this.instance = instance;
    } else {
      this.instance = this.ajax;
    }
    this.baseUrl = '';
  }
  /**
   * @return Success
   */
  getRoles(): Promise<RoleDto[]> {
    let url_ = this.baseUrl + '/api/Roles/GetRoles';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getRoleDetails(id: string | undefined): Promise<RoleDetailsDto> {
    let url_ = this.baseUrl + '/api/Roles/GetRoleDetails?';

    if (id !== undefined && id !== null) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createRole(body: RoleDto | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Roles/CreateRole';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify(body);
    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteRole(id: string | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Roles/DeleteRole?';

    if (id !== undefined && id !== null) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'DELETE',
      url: url_,
      headers: {},
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateRole(body: UpdateRoleInput | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Roles/UpdateRole';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify(body);
    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'PUT',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @return Success
   */
  getAllPermissions(): Promise<{ [key: string]: PermissionDto[] }> {
    let url_ = this.baseUrl + '/api/Roles/GetAllPermissions';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }
}

export class UsersServiceProxy extends AppServiceBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(instance?: AxiosInstance) {
    super();
    if (instance) {
      this.instance = instance;
    } else {
      this.instance = this.ajax;
    }
    this.baseUrl = '';
  }
  /**
   * @param selectedRole (optional)
   * @param orderInfo_SortField (optional)
   * @param orderInfo_SortOrder (optional)
   * @param filter (optional)
   * @param page (optional)
   * @param pageSize (optional)
   * @return Success
   */
  getAll(params: {
    selectedRole: string | undefined;
    orderInfo_SortField: string | undefined;
    orderInfo_SortOrder: string | undefined;
    filter: string | undefined;
    page: number | undefined;
    pageSize: number | undefined;
  }): Promise<PagedResultOfUserListItemDto> {
    const { selectedRole, orderInfo_SortField, orderInfo_SortOrder, filter, page, pageSize } = {
      ...params,
    };

    let url_ = this.baseUrl + '/api/Users/GetAll?';

    if (selectedRole !== undefined && selectedRole !== null)
      url_ += 'SelectedRole=' + encodeURIComponent('' + selectedRole) + '&';

    if (orderInfo_SortField !== undefined && orderInfo_SortField !== null)
      url_ += 'OrderInfo.SortField=' + encodeURIComponent('' + orderInfo_SortField) + '&';

    if (orderInfo_SortOrder !== undefined && orderInfo_SortOrder !== null)
      url_ += 'OrderInfo.SortOrder=' + encodeURIComponent('' + orderInfo_SortOrder) + '&';

    if (filter !== undefined && filter !== null)
      url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';

    if (page !== undefined && page !== null) url_ += 'Page=' + encodeURIComponent('' + page) + '&';

    if (pageSize !== undefined && pageSize !== null)
      url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param body (optional)
   * @return Success
   */
  bulkAction(body: UsersBulkActionInput | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Users/BulkAction';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify(body);
    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param body (optional)
   * @return Success
   */
  newUser(body: UserDetailsDto | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Users/NewUser';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify(body);
    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getUser(id: string | undefined): Promise<UserDetailsDto> {
    let url_ = this.baseUrl + '/api/Users/GetUser?';

    if (id !== undefined && id !== null) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UserDetailsDto | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Users/Update';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify(body);
    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: string | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Users/Delete?';

    if (id !== undefined && id !== null) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {},
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @param body (optional)
   * @return Success
   */
  editPassword(body: ResetUserPasswordtInput | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Users/EditPassword';
    url_ = url_.replace(/[?&]$/, '');
    const content_ = JSON.stringify(body);
    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }

  /**
   * @return Success
   */
  getUserSettingsTypes(): Promise<ContentTypeDefinitionDto[]> {
    let url_ = this.baseUrl + '/api/Users/GetUserSettingsTypes';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }
}

export class WorkflowApiServiceProxy extends AppServiceBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(instance?: AxiosInstance) {
    super();
    if (instance) {
      this.instance = instance;
    } else {
      this.instance = this.ajax;
    }
    this.baseUrl = '';
  }
  /**
   * 尝试使用反射获取所有 工作流的JS扩展方法（IGlobalMethodProvider）
   * @return Success
   */
  listAllGlobalMethods(): Promise<GlobalMethodDto[]> {
    let url_ = this.baseUrl + '/api/WorkflowApi/ListAllGlobalMethods';
    url_ = url_.replace(/[?&]$/, '');
    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };
    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(_response);
    });
  }
}

export class ConnectionConfigModel {
  configId!: string | undefined;
  configName!: string | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.configId = _data['configId'];
      this.configName = _data['configName'];
    }
  }

  static fromJS(data: any, _mappings?: any): ConnectionConfigModel {
    data = typeof data === 'object' ? data : {};
    return createInstance<ConnectionConfigModel>(data, _mappings, ConnectionConfigModel);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['configId'] = this.configId;
    data['configName'] = this.configName;
    return data;
  }
}

export class ContentFieldDefinitionDto {
  name!: string | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.name = _data['name'];
    }
  }

  static fromJS(data: any, _mappings?: any): ContentFieldDefinitionDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<ContentFieldDefinitionDto>(data, _mappings, ContentFieldDefinitionDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    return data;
  }
}

export class ContentItem {
  id!: number;
  contentItemId!: string | undefined;
  contentItemVersionId!: string | undefined;
  contentType!: string | undefined;
  published!: boolean;
  latest!: boolean;
  modifiedUtc!: Date | undefined;
  publishedUtc!: Date | undefined;
  createdUtc!: Date | undefined;
  owner!: string | undefined;
  author!: string | undefined;
  displayText!: string | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.contentItemId = _data['contentItemId'];
      this.contentItemVersionId = _data['contentItemVersionId'];
      this.contentType = _data['contentType'];
      this.published = _data['published'];
      this.latest = _data['latest'];
      this.modifiedUtc = _data['modifiedUtc']
        ? new Date(_data['modifiedUtc'].toString())
        : <any>undefined;
      this.publishedUtc = _data['publishedUtc']
        ? new Date(_data['publishedUtc'].toString())
        : <any>undefined;
      this.createdUtc = _data['createdUtc']
        ? new Date(_data['createdUtc'].toString())
        : <any>undefined;
      this.owner = _data['owner'];
      this.author = _data['author'];
      this.displayText = _data['displayText'];
    }
  }

  static fromJS(data: any, _mappings?: any): ContentItem {
    data = typeof data === 'object' ? data : {};
    return createInstance<ContentItem>(data, _mappings, ContentItem);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['contentItemId'] = this.contentItemId;
    data['contentItemVersionId'] = this.contentItemVersionId;
    data['contentType'] = this.contentType;
    data['published'] = this.published;
    data['latest'] = this.latest;
    data['modifiedUtc'] = this.modifiedUtc ? this.modifiedUtc.toISOString() : <any>undefined;
    data['publishedUtc'] = this.publishedUtc ? this.publishedUtc.toISOString() : <any>undefined;
    data['createdUtc'] = this.createdUtc ? this.createdUtc.toISOString() : <any>undefined;
    data['owner'] = this.owner;
    data['author'] = this.author;
    data['displayText'] = this.displayText;
    return data;
  }
}

/** Dto of OrchardCore.ContentManagement.Metadata.Models.ContentPartDefinition */
export class ContentPartDefinitionDto {
  fields!: ContentPartFieldDefinitionDto[] | undefined;
  displayName!: string | undefined;
  readonly description!: string | undefined;
  name!: string | undefined;
  settings!: any | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      if (Array.isArray(_data['fields'])) {
        this.fields = [] as any;
        for (let item of _data['fields'])
          this.fields!.push(ContentPartFieldDefinitionDto.fromJS(item, _mappings));
      }
      this.displayName = _data['displayName'];
      (<any>this).description = _data['description'];
      this.name = _data['name'];
      this.settings = _data['settings'];
    }
  }

  static fromJS(data: any, _mappings?: any): ContentPartDefinitionDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<ContentPartDefinitionDto>(data, _mappings, ContentPartDefinitionDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.fields)) {
      data['fields'] = [];
      for (let item of this.fields) data['fields'].push(item.toJSON());
    }
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    data['name'] = this.name;
    data['settings'] = this.settings;
    return data;
  }
}

export class ContentPartFieldDefinitionDto {
  fieldDefinition!: ContentFieldDefinitionDto;
  displayName!: string | undefined;
  readonly description!: string | undefined;
  name!: string | undefined;
  settings!: any | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.fieldDefinition = _data['fieldDefinition']
        ? ContentFieldDefinitionDto.fromJS(_data['fieldDefinition'], _mappings)
        : <any>undefined;
      this.displayName = _data['displayName'];
      (<any>this).description = _data['description'];
      this.name = _data['name'];
      this.settings = _data['settings'];
    }
  }

  static fromJS(data: any, _mappings?: any): ContentPartFieldDefinitionDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<ContentPartFieldDefinitionDto>(
      data,
      _mappings,
      ContentPartFieldDefinitionDto,
    );
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fieldDefinition'] = this.fieldDefinition ? this.fieldDefinition.toJSON() : <any>undefined;
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    data['name'] = this.name;
    data['settings'] = this.settings;
    return data;
  }
}

/** Dto of OrchardCore.ContentManagement.Metadata.Models.ContentTypeDefinition Converting Method EasyOC.ContentTypeDtoExtentions */
export class ContentTypeDefinitionDto {
  displayName!: string | undefined;
  parts!: ContentTypePartDefinitionDto[] | undefined;
  name!: string | undefined;
  settings!: any | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      if (Array.isArray(_data['parts'])) {
        this.parts = [] as any;
        for (let item of _data['parts'])
          this.parts!.push(ContentTypePartDefinitionDto.fromJS(item, _mappings));
      }
      this.name = _data['name'];
      this.settings = _data['settings'];
    }
  }

  static fromJS(data: any, _mappings?: any): ContentTypeDefinitionDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<ContentTypeDefinitionDto>(data, _mappings, ContentTypeDefinitionDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    if (Array.isArray(this.parts)) {
      data['parts'] = [];
      for (let item of this.parts) data['parts'].push(item.toJSON());
    }
    data['name'] = this.name;
    data['settings'] = this.settings;
    return data;
  }
}

export class ContentTypeListItemDto {
  displayName!: string | undefined;
  readonly stereotype!: string | undefined;
  name!: string | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.displayName = _data['displayName'];
      (<any>this).stereotype = _data['stereotype'];
      this.name = _data['name'];
    }
  }

  static fromJS(data: any, _mappings?: any): ContentTypeListItemDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<ContentTypeListItemDto>(data, _mappings, ContentTypeListItemDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName;
    data['stereotype'] = this.stereotype;
    data['name'] = this.name;
    return data;
  }
}

export class ContentTypePartDefinitionDto {
  partDefinition!: ContentPartDefinitionDto;
  displayName!: string | undefined;
  readonly description!: string | undefined;
  name!: string | undefined;
  settings!: any | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.partDefinition = _data['partDefinition']
        ? ContentPartDefinitionDto.fromJS(_data['partDefinition'], _mappings)
        : <any>undefined;
      this.displayName = _data['displayName'];
      (<any>this).description = _data['description'];
      this.name = _data['name'];
      this.settings = _data['settings'];
    }
  }

  static fromJS(data: any, _mappings?: any): ContentTypePartDefinitionDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<ContentTypePartDefinitionDto>(
      data,
      _mappings,
      ContentTypePartDefinitionDto,
    );
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['partDefinition'] = this.partDefinition ? this.partDefinition.toJSON() : <any>undefined;
    data['displayName'] = this.displayName;
    data['description'] = this.description;
    data['name'] = this.name;
    data['settings'] = this.settings;
    return data;
  }
}

export class CreateApiViewModel {
  description!: string | undefined;
  name!: string;
  databaseProvider!: string | undefined;
  requestUrlPrefix!: string | undefined;
  requestUrlHost!: string | undefined;
  connectionString!: string | undefined;
  tablePrefix!: string | undefined;
  recipeName!: string | undefined;
  featureProfile!: string | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.description = _data['description'];
      this.name = _data['name'];
      this.databaseProvider = _data['databaseProvider'];
      this.requestUrlPrefix = _data['requestUrlPrefix'];
      this.requestUrlHost = _data['requestUrlHost'];
      this.connectionString = _data['connectionString'];
      this.tablePrefix = _data['tablePrefix'];
      this.recipeName = _data['recipeName'];
      this.featureProfile = _data['featureProfile'];
    }
  }

  static fromJS(data: any, _mappings?: any): CreateApiViewModel {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateApiViewModel>(data, _mappings, CreateApiViewModel);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['description'] = this.description;
    data['name'] = this.name;
    data['databaseProvider'] = this.databaseProvider;
    data['requestUrlPrefix'] = this.requestUrlPrefix;
    data['requestUrlHost'] = this.requestUrlHost;
    data['connectionString'] = this.connectionString;
    data['tablePrefix'] = this.tablePrefix;
    data['recipeName'] = this.recipeName;
    data['featureProfile'] = this.featureProfile;
    return data;
  }
}

export class DbColumnInfoDto {
  name!: string | undefined;
  csType!: TypeDto;
  dbType!: number;
  dbTypeText!: string | undefined;
  dbTypeTextFull!: string | undefined;
  maxLength!: number;
  isPrimary!: boolean;
  isIdentity!: boolean;
  isNullable!: boolean;
  coment!: string | undefined;
  defaultValue!: string | undefined;
  position!: number;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.name = _data['name'];
      this.csType = _data['csType'] ? TypeDto.fromJS(_data['csType'], _mappings) : <any>undefined;
      this.dbType = _data['dbType'];
      this.dbTypeText = _data['dbTypeText'];
      this.dbTypeTextFull = _data['dbTypeTextFull'];
      this.maxLength = _data['maxLength'];
      this.isPrimary = _data['isPrimary'];
      this.isIdentity = _data['isIdentity'];
      this.isNullable = _data['isNullable'];
      this.coment = _data['coment'];
      this.defaultValue = _data['defaultValue'];
      this.position = _data['position'];
    }
  }

  static fromJS(data: any, _mappings?: any): DbColumnInfoDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<DbColumnInfoDto>(data, _mappings, DbColumnInfoDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['csType'] = this.csType ? this.csType.toJSON() : <any>undefined;
    data['dbType'] = this.dbType;
    data['dbTypeText'] = this.dbTypeText;
    data['dbTypeTextFull'] = this.dbTypeTextFull;
    data['maxLength'] = this.maxLength;
    data['isPrimary'] = this.isPrimary;
    data['isIdentity'] = this.isIdentity;
    data['isNullable'] = this.isNullable;
    data['coment'] = this.coment;
    data['defaultValue'] = this.defaultValue;
    data['position'] = this.position;
    return data;
  }
}

export class DbTableInfoDto {
  id!: string | undefined;
  columnsCount!: number;
  schema!: string | undefined;
  name!: string | undefined;
  comment!: string | undefined;
  type!: string | undefined;
  columns!: DbColumnInfoDto[] | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.columnsCount = _data['columnsCount'];
      this.schema = _data['schema'];
      this.name = _data['name'];
      this.comment = _data['comment'];
      this.type = _data['type'];
      if (Array.isArray(_data['columns'])) {
        this.columns = [] as any;
        for (let item of _data['columns'])
          this.columns!.push(DbColumnInfoDto.fromJS(item, _mappings));
      }
    }
  }

  static fromJS(data: any, _mappings?: any): DbTableInfoDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<DbTableInfoDto>(data, _mappings, DbTableInfoDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['columnsCount'] = this.columnsCount;
    data['schema'] = this.schema;
    data['name'] = this.name;
    data['comment'] = this.comment;
    data['type'] = this.type;
    if (Array.isArray(this.columns)) {
      data['columns'] = [];
      for (let item of this.columns) data['columns'].push(item.toJSON());
    }
    return data;
  }
}

export class GlobalMethodDto {
  name!: string | undefined;
  description!: string | undefined;
  parameters!: any[] | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.name = _data['name'];
      this.description = _data['description'];
      if (Array.isArray(_data['parameters'])) {
        this.parameters = [] as any;
        for (let item of _data['parameters']) this.parameters!.push(item);
      }
    }
  }

  static fromJS(data: any, _mappings?: any): GlobalMethodDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<GlobalMethodDto>(data, _mappings, GlobalMethodDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['description'] = this.description;
    if (Array.isArray(this.parameters)) {
      data['parameters'] = [];
      for (let item of this.parameters) data['parameters'].push(item);
    }
    return data;
  }
}

export class ImportJsonInupt {
  json!: string | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.json = _data['json'];
    }
  }

  static fromJS(data: any, _mappings?: any): ImportJsonInupt {
    data = typeof data === 'object' ? data : {};
    return createInstance<ImportJsonInupt>(data, _mappings, ImportJsonInupt);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['json'] = this.json;
    return data;
  }
}

export class LuceneQueryModel {
  indexName!: string | undefined;
  query!: string | undefined;
  parameters!: string | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.indexName = _data['indexName'];
      this.query = _data['query'];
      this.parameters = _data['parameters'];
    }
  }

  static fromJS(data: any, _mappings?: any): LuceneQueryModel {
    data = typeof data === 'object' ? data : {};
    return createInstance<LuceneQueryModel>(data, _mappings, LuceneQueryModel);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['indexName'] = this.indexName;
    data['query'] = this.query;
    data['parameters'] = this.parameters;
    return data;
  }
}

export class OrchardCoreBaseField {
  name!: string | undefined;
  description!: string | undefined;
  valuePath!: string | undefined;
  defaultMappToCsType!: string[] | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.name = _data['name'];
      this.description = _data['description'];
      this.valuePath = _data['valuePath'];
      if (Array.isArray(_data['defaultMappToCsType'])) {
        this.defaultMappToCsType = [] as any;
        for (let item of _data['defaultMappToCsType']) this.defaultMappToCsType!.push(item);
      }
    }
  }

  static fromJS(data: any, _mappings?: any): OrchardCoreBaseField {
    data = typeof data === 'object' ? data : {};
    return createInstance<OrchardCoreBaseField>(data, _mappings, OrchardCoreBaseField);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['description'] = this.description;
    data['valuePath'] = this.valuePath;
    if (Array.isArray(this.defaultMappToCsType)) {
      data['defaultMappToCsType'] = [];
      for (let item of this.defaultMappToCsType) data['defaultMappToCsType'].push(item);
    }
    return data;
  }
}

export class PagedResultOfContentPartDefinitionDto {
  total!: number;
  items!: ContentPartDefinitionDto[] | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.total = _data['total'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(ContentPartDefinitionDto.fromJS(item, _mappings));
      }
    }
  }

  static fromJS(data: any, _mappings?: any): PagedResultOfContentPartDefinitionDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<PagedResultOfContentPartDefinitionDto>(
      data,
      _mappings,
      PagedResultOfContentPartDefinitionDto,
    );
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['total'] = this.total;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export class PagedResultOfContentTypeListItemDto {
  total!: number;
  items!: ContentTypeListItemDto[] | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.total = _data['total'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(ContentTypeListItemDto.fromJS(item, _mappings));
      }
    }
  }

  static fromJS(data: any, _mappings?: any): PagedResultOfContentTypeListItemDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<PagedResultOfContentTypeListItemDto>(
      data,
      _mappings,
      PagedResultOfContentTypeListItemDto,
    );
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['total'] = this.total;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export class PagedResultOfUserListItemDto {
  total!: number;
  items!: UserListItemDto[] | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.total = _data['total'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(UserListItemDto.fromJS(item, _mappings));
      }
    }
  }

  static fromJS(data: any, _mappings?: any): PagedResultOfUserListItemDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<PagedResultOfUserListItemDto>(
      data,
      _mappings,
      PagedResultOfUserListItemDto,
    );
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['total'] = this.total;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export class PermissionDto {
  name!: string | undefined;
  description!: string | undefined;
  category!: string | undefined;
  impliedBy!: PermissionDto[] | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.name = _data['name'];
      this.description = _data['description'];
      this.category = _data['category'];
      if (Array.isArray(_data['impliedBy'])) {
        this.impliedBy = [] as any;
        for (let item of _data['impliedBy'])
          this.impliedBy!.push(PermissionDto.fromJS(item, _mappings));
      }
    }
  }

  static fromJS(data: any, _mappings?: any): PermissionDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<PermissionDto>(data, _mappings, PermissionDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['description'] = this.description;
    data['category'] = this.category;
    if (Array.isArray(this.impliedBy)) {
      data['impliedBy'] = [];
      for (let item of this.impliedBy) data['impliedBy'].push(item.toJSON());
    }
    return data;
  }
}

export class ResetUserPasswordtInput {
  email!: string | undefined;
  newPassword!: string | undefined;
  passwordConfirmation!: string | undefined;
  resetToken!: string | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.email = _data['email'];
      this.newPassword = _data['newPassword'];
      this.passwordConfirmation = _data['passwordConfirmation'];
      this.resetToken = _data['resetToken'];
    }
  }

  static fromJS(data: any, _mappings?: any): ResetUserPasswordtInput {
    data = typeof data === 'object' ? data : {};
    return createInstance<ResetUserPasswordtInput>(data, _mappings, ResetUserPasswordtInput);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['newPassword'] = this.newPassword;
    data['passwordConfirmation'] = this.passwordConfirmation;
    data['resetToken'] = this.resetToken;
    return data;
  }
}

export class RoleClaimDto {
  claimType!: string | undefined;
  claimValue!: string | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.claimType = _data['claimType'];
      this.claimValue = _data['claimValue'];
    }
  }

  static fromJS(data: any, _mappings?: any): RoleClaimDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<RoleClaimDto>(data, _mappings, RoleClaimDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['claimType'] = this.claimType;
    data['claimValue'] = this.claimValue;
    return data;
  }
}

export class RoleDetailsDto {
  name!: string | undefined;
  roleDescription!: string | undefined;
  roleCategoryPermissions!: { [key: string]: PermissionDto[] } | undefined;
  effectivePermissions!: string[] | undefined;
  role!: RoleDto;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.name = _data['name'];
      this.roleDescription = _data['roleDescription'];
      if (_data['roleCategoryPermissions']) {
        this.roleCategoryPermissions = {} as any;
        for (let key in _data['roleCategoryPermissions']) {
          if (_data['roleCategoryPermissions'].hasOwnProperty(key))
            this.roleCategoryPermissions![key] = _data['roleCategoryPermissions'][key]
              ? _data['roleCategoryPermissions'][key].map((i: any) =>
                  PermissionDto.fromJS(i, _mappings),
                )
              : [];
        }
      }
      if (Array.isArray(_data['effectivePermissions'])) {
        this.effectivePermissions = [] as any;
        for (let item of _data['effectivePermissions']) this.effectivePermissions!.push(item);
      }
      this.role = _data['role'] ? RoleDto.fromJS(_data['role'], _mappings) : <any>undefined;
    }
  }

  static fromJS(data: any, _mappings?: any): RoleDetailsDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<RoleDetailsDto>(data, _mappings, RoleDetailsDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['roleDescription'] = this.roleDescription;
    if (this.roleCategoryPermissions) {
      data['roleCategoryPermissions'] = {};
      for (let key in this.roleCategoryPermissions) {
        if (this.roleCategoryPermissions.hasOwnProperty(key))
          data['roleCategoryPermissions'][key] = this.roleCategoryPermissions[key];
      }
    }
    if (Array.isArray(this.effectivePermissions)) {
      data['effectivePermissions'] = [];
      for (let item of this.effectivePermissions) data['effectivePermissions'].push(item);
    }
    data['role'] = this.role ? this.role.toJSON() : <any>undefined;
    return data;
  }
}

export class RoleDto {
  roleName!: string | undefined;
  roleDescription!: string | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.roleName = _data['roleName'];
      this.roleDescription = _data['roleDescription'];
    }
  }

  static fromJS(data: any, _mappings?: any): RoleDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<RoleDto>(data, _mappings, RoleDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['roleName'] = this.roleName;
    data['roleDescription'] = this.roleDescription;
    return data;
  }
}

export class SelectListGroup {
  disabled!: boolean;
  name!: string | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.disabled = _data['disabled'];
      this.name = _data['name'];
    }
  }

  static fromJS(data: any, _mappings?: any): SelectListGroup {
    data = typeof data === 'object' ? data : {};
    return createInstance<SelectListGroup>(data, _mappings, SelectListGroup);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['disabled'] = this.disabled;
    data['name'] = this.name;
    return data;
  }
}

export class SelectListItem {
  disabled!: boolean;
  group!: SelectListGroup;
  selected!: boolean;
  text!: string | undefined;
  value!: string | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.disabled = _data['disabled'];
      this.group = _data['group']
        ? SelectListGroup.fromJS(_data['group'], _mappings)
        : <any>undefined;
      this.selected = _data['selected'];
      this.text = _data['text'];
      this.value = _data['value'];
    }
  }

  static fromJS(data: any, _mappings?: any): SelectListItem {
    data = typeof data === 'object' ? data : {};
    return createInstance<SelectListItem>(data, _mappings, SelectListItem);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['disabled'] = this.disabled;
    data['group'] = this.group ? this.group.toJSON() : <any>undefined;
    data['selected'] = this.selected;
    data['text'] = this.text;
    data['value'] = this.value;
    return data;
  }
}

export class SetupApiViewModel {
  name!: string;
  siteName!: string;
  databaseProvider!: string | undefined;
  connectionString!: string | undefined;
  tablePrefix!: string | undefined;
  userName!: string;
  email!: string;
  password!: string | undefined;
  recipeName!: string | undefined;
  recipe!: string | undefined;
  siteTimeZone!: string | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.name = _data['name'];
      this.siteName = _data['siteName'];
      this.databaseProvider = _data['databaseProvider'];
      this.connectionString = _data['connectionString'];
      this.tablePrefix = _data['tablePrefix'];
      this.userName = _data['userName'];
      this.email = _data['email'];
      this.password = _data['password'];
      this.recipeName = _data['recipeName'];
      this.recipe = _data['recipe'];
      this.siteTimeZone = _data['siteTimeZone'];
    }
  }

  static fromJS(data: any, _mappings?: any): SetupApiViewModel {
    data = typeof data === 'object' ? data : {};
    return createInstance<SetupApiViewModel>(data, _mappings, SetupApiViewModel);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['siteName'] = this.siteName;
    data['databaseProvider'] = this.databaseProvider;
    data['connectionString'] = this.connectionString;
    data['tablePrefix'] = this.tablePrefix;
    data['userName'] = this.userName;
    data['email'] = this.email;
    data['password'] = this.password;
    data['recipeName'] = this.recipeName;
    data['recipe'] = this.recipe;
    data['siteTimeZone'] = this.siteTimeZone;
    return data;
  }
}

export class TypeDto {
  name!: string | undefined;
  fullName!: string | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.name = _data['name'];
      this.fullName = _data['fullName'];
    }
  }

  static fromJS(data: any, _mappings?: any): TypeDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<TypeDto>(data, _mappings, TypeDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['fullName'] = this.fullName;
    return data;
  }
}

export class UpdateRoleInput {
  roleName!: string | undefined;
  roleDescription!: string | undefined;
  normalizedRoleName!: string | undefined;
  roleClaims!: RoleClaimDto[] | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.roleName = _data['roleName'];
      this.roleDescription = _data['roleDescription'];
      this.normalizedRoleName = _data['normalizedRoleName'];
      if (Array.isArray(_data['roleClaims'])) {
        this.roleClaims = [] as any;
        for (let item of _data['roleClaims'])
          this.roleClaims!.push(RoleClaimDto.fromJS(item, _mappings));
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateRoleInput {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateRoleInput>(data, _mappings, UpdateRoleInput);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['roleName'] = this.roleName;
    data['roleDescription'] = this.roleDescription;
    data['normalizedRoleName'] = this.normalizedRoleName;
    if (Array.isArray(this.roleClaims)) {
      data['roleClaims'] = [];
      for (let item of this.roleClaims) data['roleClaims'].push(item.toJSON());
    }
    return data;
  }
}

export class UserDetailsDto {
  id!: number | undefined;
  userId!: string | undefined;
  userName!: string | undefined;
  normalizedUserName!: string | undefined;
  email!: string | undefined;
  normalizedEmail!: string | undefined;
  emailConfirmed!: boolean;
  isEnabled!: boolean;
  isLockoutEnabled!: boolean;
  lockoutEndUtc!: Date | undefined;
  accessFailedCount!: number;
  roleNames!: string[] | undefined;
  properties!: any | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.userId = _data['userId'];
      this.userName = _data['userName'];
      this.normalizedUserName = _data['normalizedUserName'];
      this.email = _data['email'];
      this.normalizedEmail = _data['normalizedEmail'];
      this.emailConfirmed = _data['emailConfirmed'];
      this.isEnabled = _data['isEnabled'];
      this.isLockoutEnabled = _data['isLockoutEnabled'];
      this.lockoutEndUtc = _data['lockoutEndUtc']
        ? new Date(_data['lockoutEndUtc'].toString())
        : <any>undefined;
      this.accessFailedCount = _data['accessFailedCount'];
      if (Array.isArray(_data['roleNames'])) {
        this.roleNames = [] as any;
        for (let item of _data['roleNames']) this.roleNames!.push(item);
      }
      this.properties = _data['properties'];
    }
  }

  static fromJS(data: any, _mappings?: any): UserDetailsDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<UserDetailsDto>(data, _mappings, UserDetailsDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userId'] = this.userId;
    data['userName'] = this.userName;
    data['normalizedUserName'] = this.normalizedUserName;
    data['email'] = this.email;
    data['normalizedEmail'] = this.normalizedEmail;
    data['emailConfirmed'] = this.emailConfirmed;
    data['isEnabled'] = this.isEnabled;
    data['isLockoutEnabled'] = this.isLockoutEnabled;
    data['lockoutEndUtc'] = this.lockoutEndUtc ? this.lockoutEndUtc.toISOString() : <any>undefined;
    data['accessFailedCount'] = this.accessFailedCount;
    if (Array.isArray(this.roleNames)) {
      data['roleNames'] = [];
      for (let item of this.roleNames) data['roleNames'].push(item);
    }
    data['properties'] = this.properties;
    return data;
  }
}

export class UserListItemDto {
  id!: number | undefined;
  userId!: string | undefined;
  userName!: string | undefined;
  normalizedUserName!: string | undefined;
  email!: string | undefined;
  emailConfirmed!: boolean;
  isEnabled!: boolean;
  isLockoutEnabled!: boolean;
  lockoutEndUtc!: Date | undefined;
  accessFailedCount!: number;
  roleNames!: string[] | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'];
      this.userId = _data['userId'];
      this.userName = _data['userName'];
      this.normalizedUserName = _data['normalizedUserName'];
      this.email = _data['email'];
      this.emailConfirmed = _data['emailConfirmed'];
      this.isEnabled = _data['isEnabled'];
      this.isLockoutEnabled = _data['isLockoutEnabled'];
      this.lockoutEndUtc = _data['lockoutEndUtc']
        ? new Date(_data['lockoutEndUtc'].toString())
        : <any>undefined;
      this.accessFailedCount = _data['accessFailedCount'];
      if (Array.isArray(_data['roleNames'])) {
        this.roleNames = [] as any;
        for (let item of _data['roleNames']) this.roleNames!.push(item);
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UserListItemDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<UserListItemDto>(data, _mappings, UserListItemDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userId'] = this.userId;
    data['userName'] = this.userName;
    data['normalizedUserName'] = this.normalizedUserName;
    data['email'] = this.email;
    data['emailConfirmed'] = this.emailConfirmed;
    data['isEnabled'] = this.isEnabled;
    data['isLockoutEnabled'] = this.isLockoutEnabled;
    data['lockoutEndUtc'] = this.lockoutEndUtc ? this.lockoutEndUtc.toISOString() : <any>undefined;
    data['accessFailedCount'] = this.accessFailedCount;
    if (Array.isArray(this.roleNames)) {
      data['roleNames'] = [];
      for (let item of this.roleNames) data['roleNames'].push(item);
    }
    return data;
  }
}

export class UsersBulkActionInput {
  bulkAction!: UsersBulkActionInputBulkAction;
  itemIds!: string[] | undefined;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.bulkAction = _data['bulkAction'];
      if (Array.isArray(_data['itemIds'])) {
        this.itemIds = [] as any;
        for (let item of _data['itemIds']) this.itemIds!.push(item);
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UsersBulkActionInput {
    data = typeof data === 'object' ? data : {};
    return createInstance<UsersBulkActionInput>(data, _mappings, UsersBulkActionInput);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['bulkAction'] = this.bulkAction;
    if (Array.isArray(this.itemIds)) {
      data['itemIds'] = [];
      for (let item of this.itemIds) data['itemIds'].push(item);
    }
    return data;
  }
}

export enum SyncMappingDeriction {
  OrchardCoreToRDBMS = 0,
  RDBMSToOrchardCore = 1,
  TwoWay = 2,
}

export enum UsersBulkActionInputBulkAction {
  None = 0,
  Delete = 1,
  Enable = 2,
  Disable = 3,
  Approve = 4,
  ChallengeEmail = 5,
}

function jsonParse(json: any, reviver?: any) {
  json = JSON.parse(json, reviver);

  var byid: any = {};
  var refs: any = [];
  json = (function recurse(obj: any, prop?: any, parent?: any) {
    if (typeof obj !== 'object' || !obj) return obj;

    if ('$ref' in obj) {
      let ref = obj.$ref;
      if (ref in byid) return byid[ref];
      refs.push([parent, prop, ref]);
      return undefined;
    } else if ('$id' in obj) {
      let id = obj.$id;
      delete obj.$id;
      if ('$values' in obj) obj = obj.$values;
      byid[id] = obj;
    }

    if (Array.isArray(obj)) {
      obj = obj.map((v, i) => recurse(v, i, obj));
    } else {
      for (var p in obj) {
        if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
          obj[p] = recurse(obj[p], p, obj);
      }
    }

    return obj;
  })(json);

  for (let i = 0; i < refs.length; i++) {
    const ref = refs[i];
    ref[0][ref[1]] = byid[ref[2]];
  }

  return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T {
  if (!mappings) mappings = [];
  else {
    let mapping = mappings.filter((m: any) => m.source === data);
    if (mapping.length === 1) return <T>mapping[0].target;
  }

  let result: any = new type();
  mappings.push({ source: data, target: result });
  result.init(data, mappings);
  return result;
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any,
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any,
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}
