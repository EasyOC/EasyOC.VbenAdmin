/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.6.2.0 (NJsonSchema v10.1.23.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
import { AppServiceBase } from './app-service-base';

export class ApiServiceProxy extends AppServiceBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(instance?: AxiosInstance) {
    super();
    if (instance) {
      this.instance = instance;
    } else {
      this.instance = this.ajax;
    }
    this.baseUrl = '';
  }

  /**
   * @return Success
   */
  contentGet(contentItemId: string): Promise<void> {
    let url_ = this.baseUrl + '/api/content/{contentItemId}';
    if (contentItemId === undefined || contentItemId === null)
      throw new Error("The parameter 'contentItemId' must be defined.");
    url_ = url_.replace('{contentItemId}', encodeURIComponent('' + contentItemId));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processContentGet(_response),
      );
    });
  }

  protected processContentGet(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @return Success
   */
  contentDelete(contentItemId: string): Promise<void> {
    let url_ = this.baseUrl + '/api/content/{contentItemId}';
    if (contentItemId === undefined || contentItemId === null)
      throw new Error("The parameter 'contentItemId' must be defined.");
    url_ = url_.replace('{contentItemId}', encodeURIComponent('' + contentItemId));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'DELETE',
      url: url_,
      headers: {},
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processContentDelete(_response),
      );
    });
  }

  protected processContentDelete(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param draft (optional)
   * @param body (optional)
   * @return Success
   */
  contentPost(draft: boolean | undefined, body: ContentItem | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/content?';

    if (draft !== undefined && draft !== null)
      url_ += 'draft=' + encodeURIComponent('' + draft) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processContentPost(_response),
      );
    });
  }

  protected processContentPost(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param parameters (optional)
   * @return Success
   */
  queriesPost(name: string, parameters: string | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/queries/{name}?';
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace('{name}', encodeURIComponent('' + name));

    if (parameters !== undefined && parameters !== null)
      url_ += 'parameters=' + encodeURIComponent('' + parameters) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {},
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processQueriesPost(_response),
      );
    });
  }

  protected processQueriesPost(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param parameters (optional)
   * @return Success
   */
  queriesGet(name: string, parameters: string | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/queries/{name}?';
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace('{name}', encodeURIComponent('' + name));

    if (parameters !== undefined && parameters !== null)
      url_ += 'parameters=' + encodeURIComponent('' + parameters) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processQueriesGet(_response),
      );
    });
  }

  protected processQueriesGet(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class LuceneServiceProxy extends AppServiceBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(instance?: AxiosInstance) {
    super();
    if (instance) {
      this.instance = instance;
    } else {
      this.instance = this.ajax;
    }
    this.baseUrl = '';
  }

  /**
   * @param indexName (optional)
   * @param query (optional)
   * @param parameters (optional)
   * @return Success
   */
  contentGet(
    indexName: string | undefined,
    query: string | undefined,
    parameters: string | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/lucene/content?';

    if (indexName !== undefined && indexName !== null)
      url_ += 'IndexName=' + encodeURIComponent('' + indexName) + '&';

    if (query !== undefined && query !== null)
      url_ += 'Query=' + encodeURIComponent('' + query) + '&';

    if (parameters !== undefined && parameters !== null)
      url_ += 'Parameters=' + encodeURIComponent('' + parameters) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processContentGet(_response),
      );
    });
  }

  protected processContentGet(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  contentPost(body: LuceneQueryModel | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/lucene/content';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processContentPost(_response),
      );
    });
  }

  protected processContentPost(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param indexName (optional)
   * @param query (optional)
   * @param parameters (optional)
   * @return Success
   */
  documentsGet(
    indexName: string | undefined,
    query: string | undefined,
    parameters: string | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/lucene/documents?';

    if (indexName !== undefined && indexName !== null)
      url_ += 'IndexName=' + encodeURIComponent('' + indexName) + '&';

    if (query !== undefined && query !== null)
      url_ += 'Query=' + encodeURIComponent('' + query) + '&';

    if (parameters !== undefined && parameters !== null)
      url_ += 'Parameters=' + encodeURIComponent('' + parameters) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {},
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processDocumentsGet(_response),
      );
    });
  }

  protected processDocumentsGet(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  documentsPost(body: LuceneQueryModel | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/lucene/documents';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processDocumentsPost(_response),
      );
    });
  }

  protected processDocumentsPost(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class TenantsServiceProxy extends AppServiceBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(instance?: AxiosInstance) {
    super();
    if (instance) {
      this.instance = instance;
    } else {
      this.instance = this.ajax;
    }
    this.baseUrl = '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateApiViewModel | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/tenants/create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processCreate(_response),
      );
    });
  }

  protected processCreate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  setup(body: SetupApiViewModel | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/tenants/setup';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processSetup(_response),
      );
    });
  }

  protected processSetup(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class ContentManagementServiceProxy extends AppServiceBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(instance?: AxiosInstance) {
    super();
    if (instance) {
      this.instance = instance;
    } else {
      this.instance = this.ajax;
    }
    this.baseUrl = '';
  }

  /**
   * 列出所有类型定义
   * @return Success
   */
  getAllTypes(): Promise<{ [key: string]: string }> {
    let url_ = this.baseUrl + '/api/ContentManagement/GetAllTypes';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processGetAllTypes(_response),
      );
    });
  }

  protected processGetAllTypes(response: AxiosResponse): Promise<{ [key: string]: string }> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      let result200: any = null;
      let resultData200 = _responseText;
      if (resultData200) {
        result200 = {} as any;
        for (let key in resultData200) {
          if (resultData200.hasOwnProperty(key)) result200![key] = resultData200[key];
        }
      }
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<{ [key: string]: string }>(<any>null);
  }

  /**
   * @return Success
   */
  getAllParts(): Promise<string[]> {
    let url_ = this.baseUrl + '/api/ContentManagement/GetAllParts';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processGetAllParts(_response),
      );
    });
  }

  protected processGetAllParts(response: AxiosResponse): Promise<string[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(item);
      }
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<string[]>(<any>null);
  }

  /**
   * @param name (optional)
   * @param incloudeSettings (optional)
   * @return Success
   */
  getPartDefinition(
    name: string | undefined,
    incloudeSettings: boolean | undefined,
  ): Promise<ContentPartApiModel> {
    let url_ = this.baseUrl + '/api/ContentManagement/GetPartDefinition?';

    if (name !== undefined && name !== null) url_ += 'name=' + encodeURIComponent('' + name) + '&';

    if (incloudeSettings !== undefined && incloudeSettings !== null)
      url_ += 'incloudeSettings=' + encodeURIComponent('' + incloudeSettings) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processGetPartDefinition(_response),
      );
    });
  }

  protected processGetPartDefinition(response: AxiosResponse): Promise<ContentPartApiModel> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      const _responseText = response.data.result;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ContentPartApiModel.fromJS(resultData200, _mappings);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<ContentPartApiModel>(<any>null);
  }

  /**
   * @param name (optional)
   * @param incloudeSettings (optional)
   * @return Success
   */
  getTypeDefinition(
    name: string | undefined,
    incloudeSettings: boolean | undefined,
  ): Promise<ContentTypeApiModel> {
    let url_ = this.baseUrl + '/api/ContentManagement/GetTypeDefinition?';

    if (name !== undefined && name !== null) url_ += 'name=' + encodeURIComponent('' + name) + '&';

    if (incloudeSettings !== undefined && incloudeSettings !== null)
      url_ += 'incloudeSettings=' + encodeURIComponent('' + incloudeSettings) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processGetTypeDefinition(_response),
      );
    });
  }

  protected processGetTypeDefinition(response: AxiosResponse): Promise<ContentTypeApiModel> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      const _responseText = response.data.result;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ContentTypeApiModel.fromJS(resultData200, _mappings);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<ContentTypeApiModel>(<any>null);
  }
}

export class ContentMappingServiceProxy extends AppServiceBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(instance?: AxiosInstance) {
    super();
    if (instance) {
      this.instance = instance;
    } else {
      this.instance = this.ajax;
    }
    this.baseUrl = '';
  }

  /**
   * OC Content to RDBMS
   * @param contentTypeName (optional)
   * @return Success
   */
  getContentTypeMappingRDBMSResult(contentTypeName: string | undefined): Promise<any> {
    let url_ = this.baseUrl + '/api/ContentMapping/GetContentTypeMappingRDBMSResult?';

    if (contentTypeName !== undefined && contentTypeName !== null)
      url_ += 'contentTypeName=' + encodeURIComponent('' + contentTypeName) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processGetContentTypeMappingRDBMSResult(_response),
      );
    });
  }

  protected processGetContentTypeMappingRDBMSResult(response: AxiosResponse): Promise<any> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<any>(<any>null);
  }

  /**
   * RDBMS TO OC Content
   * @param tableName (optional)
   * @param contentTypeName (optional)
   * @return Success
   */
  getRDBMSMappingContentTypeResult(
    tableName: string | undefined,
    contentTypeName: string | undefined,
  ): Promise<any> {
    let url_ = this.baseUrl + '/api/ContentMapping/GetRDBMSMappingContentTypeResult?';

    if (tableName !== undefined && tableName !== null)
      url_ += 'tableName=' + encodeURIComponent('' + tableName) + '&';

    if (contentTypeName !== undefined && contentTypeName !== null)
      url_ += 'contentTypeName=' + encodeURIComponent('' + contentTypeName) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processGetRDBMSMappingContentTypeResult(_response),
      );
    });
  }

  protected processGetRDBMSMappingContentTypeResult(response: AxiosResponse): Promise<any> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<any>(<any>null);
  }
}

export class ExcelServiceProxy extends AppServiceBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(instance?: AxiosInstance) {
    super();
    if (instance) {
      this.instance = instance;
    } else {
      this.instance = this.ajax;
    }
    this.baseUrl = '';
  }

  /**
   * @param fileFullPath (optional)
   * @param rowFilterExpression (optional)
   * @return Success
   */
  getExcelDataFromConfig(
    fileFullPath: string | undefined,
    rowFilterExpression: string | undefined,
  ): Promise<any> {
    let url_ = this.baseUrl + '/api/Excel/GetExcelDataFromConfig?';

    if (fileFullPath !== undefined && fileFullPath !== null)
      url_ += 'fileFullPath=' + encodeURIComponent('' + fileFullPath) + '&';

    if (rowFilterExpression !== undefined && rowFilterExpression !== null)
      url_ += 'rowFilterExpression=' + encodeURIComponent('' + rowFilterExpression) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processGetExcelDataFromConfig(_response),
      );
    });
  }

  protected processGetExcelDataFromConfig(response: AxiosResponse): Promise<any> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<any>(<any>null);
  }

  /**
   * @param fileFullPath (optional)
   * @param configDocumentId (optional)
   * @param rowFilterExpression (optional)
   * @return Success
   */
  getProcessedData(
    fileFullPath: string | undefined,
    configDocumentId: string | undefined,
    rowFilterExpression: string | undefined,
  ): Promise<any[]> {
    let url_ = this.baseUrl + '/api/Excel/GetProcessedData?';

    if (fileFullPath !== undefined && fileFullPath !== null)
      url_ += 'fileFullPath=' + encodeURIComponent('' + fileFullPath) + '&';

    if (configDocumentId !== undefined && configDocumentId !== null)
      url_ += 'configDocumentId=' + encodeURIComponent('' + configDocumentId) + '&';

    if (rowFilterExpression !== undefined && rowFilterExpression !== null)
      url_ += 'rowFilterExpression=' + encodeURIComponent('' + rowFilterExpression) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processGetProcessedData(_response),
      );
    });
  }

  protected processGetProcessedData(response: AxiosResponse): Promise<any[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(item);
      }
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<any[]>(<any>null);
  }

  /**
   * @return Success
   */
  getAllExcelSettings(): Promise<SelectListItem[]> {
    let url_ = this.baseUrl + '/api/Excel/GetAllExcelSettings';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processGetAllExcelSettings(_response),
      );
    });
  }

  protected processGetAllExcelSettings(response: AxiosResponse): Promise<SelectListItem[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      const _responseText = response.data.result;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(SelectListItem.fromJS(item, _mappings));
      }
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<SelectListItem[]>(<any>null);
  }
}

export class RDBMSServiceProxy extends AppServiceBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(instance?: AxiosInstance) {
    super();
    if (instance) {
      this.instance = instance;
    } else {
      this.instance = this.ajax;
    }
    this.baseUrl = '';
  }

  /**
   * Get all Connection Config
   * @return Success
   */
  getAllDbConnecton(): Promise<ConnectionConfigModel[]> {
    let url_ = this.baseUrl + '/api/RDBMS/GetAllDbConnecton';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processGetAllDbConnecton(_response),
      );
    });
  }

  protected processGetAllDbConnecton(response: AxiosResponse): Promise<ConnectionConfigModel[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      const _responseText = response.data.result;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200)
          result200!.push(ConnectionConfigModel.fromJS(item, _mappings));
      }
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<ConnectionConfigModel[]>(<any>null);
  }

  /**
   * 根据连接设置获取指定数据库的表信息
   * @param connectionConfigId (optional)
   * @param disableCache (optional)
   * @param filterText (optional)
   * @param maxResultCount (optional)
   * @param skipCount (optional)
   * @return Success
   */
  getAllTables(
    connectionConfigId: string | undefined,
    disableCache: boolean | undefined,
    filterText: string | undefined,
    maxResultCount: number | undefined,
    skipCount: number | undefined,
  ): Promise<DbTableInfoDto[]> {
    let url_ = this.baseUrl + '/api/RDBMS/GetAllTables?';

    if (connectionConfigId !== undefined && connectionConfigId !== null)
      url_ += 'ConnectionConfigId=' + encodeURIComponent('' + connectionConfigId) + '&';

    if (disableCache !== undefined && disableCache !== null)
      url_ += 'DisableCache=' + encodeURIComponent('' + disableCache) + '&';

    if (filterText !== undefined && filterText !== null)
      url_ += 'FilterText=' + encodeURIComponent('' + filterText) + '&';

    if (maxResultCount !== undefined && maxResultCount !== null)
      url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&';

    if (skipCount !== undefined && skipCount !== null)
      url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processGetAllTables(_response),
      );
    });
  }

  protected processGetAllTables(response: AxiosResponse): Promise<DbTableInfoDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      const _responseText = response.data.result;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(DbTableInfoDto.fromJS(item, _mappings));
      }
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<DbTableInfoDto[]>(<any>null);
  }

  /**
   * @param connectionConfigId (optional)
   * @param tableName (optional) 表名，如：dbo.table1
   * @return Success
   */
  getTableDetails(
    connectionConfigId: string | undefined,
    tableName: string | undefined,
  ): Promise<DbTableInfoDto> {
    let url_ = this.baseUrl + '/api/RDBMS/GetTableDetails?';

    if (connectionConfigId !== undefined && connectionConfigId !== null)
      url_ += 'connectionConfigId=' + encodeURIComponent('' + connectionConfigId) + '&';

    if (tableName !== undefined && tableName !== null)
      url_ += 'tableName=' + encodeURIComponent('' + tableName) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processGetTableDetails(_response),
      );
    });
  }

  protected processGetTableDetails(response: AxiosResponse): Promise<DbTableInfoDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      const _responseText = response.data.result;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = DbTableInfoDto.fromJS(resultData200, _mappings);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<DbTableInfoDto>(<any>null);
  }

  /**
   * @param connectionConfigId (optional)
   * @param tableName (optional)
   * @return Success
   */
  generateRecipe(
    connectionConfigId: string | undefined,
    tableName: string | undefined,
  ): Promise<string> {
    let url_ = this.baseUrl + '/api/RDBMS/GenerateRecipe?';

    if (connectionConfigId !== undefined && connectionConfigId !== null)
      url_ += 'connectionConfigId=' + encodeURIComponent('' + connectionConfigId) + '&';

    if (tableName !== undefined && tableName !== null)
      url_ += 'tableName=' + encodeURIComponent('' + tableName) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processGenerateRecipe(_response),
      );
    });
  }

  protected processGenerateRecipe(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<string>(<any>null);
  }

  /**
   * @return Success
   */
  getAllOrchardCoreBaseFields(): Promise<OrchardCoreBaseField[]> {
    let url_ = this.baseUrl + '/api/RDBMS/GetAllOrchardCoreBaseFields';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processGetAllOrchardCoreBaseFields(_response),
      );
    });
  }

  protected processGetAllOrchardCoreBaseFields(
    response: AxiosResponse,
  ): Promise<OrchardCoreBaseField[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      const _responseText = response.data.result;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200)
          result200!.push(OrchardCoreBaseField.fromJS(item, _mappings));
      }
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<OrchardCoreBaseField[]>(<any>null);
  }

  /**
   * 使用JSON更新类型
   * @param body (optional)
   * @return Success
   */
  importDeploymentPackage(body: ImportJsonInupt | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/RDBMS/ImportDeploymentPackage';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processImportDeploymentPackage(_response),
      );
    });
  }

  protected processImportDeploymentPackage(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @param configName (optional)
   * @param contentTypeName (optional)
   * @param connectionConfigId (optional)
   * @param targetTable (optional)
   * @param mappingData (optional)
   * @param readOnly (optional)
   * @param enableAutoSync (optional)
   * @return Success
   */
  getTableInfo(
    id: string | undefined,
    configName: string | undefined,
    contentTypeName: string | undefined,
    syncMappingDeriction: SyncMappingDeriction,
    connectionConfigId: string | undefined,
    targetTable: string | undefined,
    mappingData: string | undefined,
    readOnly: boolean | undefined,
    enableAutoSync: boolean | undefined,
  ): Promise<any> {
    let url_ = this.baseUrl + '/api/RDBMS/GetTableInfo?';

    if (id !== undefined && id !== null) url_ += 'Id=' + encodeURIComponent('' + id) + '&';

    if (configName !== undefined && configName !== null)
      url_ += 'ConfigName=' + encodeURIComponent('' + configName) + '&';

    if (contentTypeName !== undefined && contentTypeName !== null)
      url_ += 'ContentTypeName=' + encodeURIComponent('' + contentTypeName) + '&';
    if (syncMappingDeriction === undefined || syncMappingDeriction === null)
      throw new Error("The parameter 'syncMappingDeriction' must be defined and cannot be null.");
    else url_ += 'SyncMappingDeriction=' + encodeURIComponent('' + syncMappingDeriction) + '&';

    if (connectionConfigId !== undefined && connectionConfigId !== null)
      url_ += 'ConnectionConfigId=' + encodeURIComponent('' + connectionConfigId) + '&';

    if (targetTable !== undefined && targetTable !== null)
      url_ += 'TargetTable=' + encodeURIComponent('' + targetTable) + '&';

    if (mappingData !== undefined && mappingData !== null)
      url_ += 'MappingData=' + encodeURIComponent('' + mappingData) + '&';

    if (readOnly !== undefined && readOnly !== null)
      url_ += 'ReadOnly=' + encodeURIComponent('' + readOnly) + '&';

    if (enableAutoSync !== undefined && enableAutoSync !== null)
      url_ += 'EnableAutoSync=' + encodeURIComponent('' + enableAutoSync) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processGetTableInfo(_response),
      );
    });
  }

  protected processGetTableInfo(response: AxiosResponse): Promise<any> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<any>(<any>null);
  }
}

export class RolesServiceProxy extends AppServiceBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(instance?: AxiosInstance) {
    super();
    if (instance) {
      this.instance = instance;
    } else {
      this.instance = this.ajax;
    }
    this.baseUrl = '';
  }

  /**
   * @return Success
   */
  getRoles(): Promise<RoleDto[]> {
    let url_ = this.baseUrl + '/api/Roles/GetRoles';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processGetRoles(_response),
      );
    });
  }

  protected processGetRoles(response: AxiosResponse): Promise<RoleDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      const _responseText = response.data.result;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(RoleDto.fromJS(item, _mappings));
      }
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<RoleDto[]>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getRoleDetails(id: string | undefined): Promise<RoleDetailsDto> {
    let url_ = this.baseUrl + '/api/Roles/GetRoleDetails?';

    if (id !== undefined && id !== null) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processGetRoleDetails(_response),
      );
    });
  }

  protected processGetRoleDetails(response: AxiosResponse): Promise<RoleDetailsDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      const _responseText = response.data.result;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = RoleDetailsDto.fromJS(resultData200, _mappings);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<RoleDetailsDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createRole(body: RoleDto | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Roles/CreateRole';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processCreateRole(_response),
      );
    });
  }

  protected processCreateRole(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteRole(id: string | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Roles/DeleteRole?';

    if (id !== undefined && id !== null) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'DELETE',
      url: url_,
      headers: {},
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processDeleteRole(_response),
      );
    });
  }

  protected processDeleteRole(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateRole(body: UpdateRoleInput | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Roles/UpdateRole';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'PUT',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processUpdateRole(_response),
      );
    });
  }

  protected processUpdateRole(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @return Success
   */
  getAllPermissions(): Promise<{ [key: string]: PermissionDto[] }> {
    let url_ = this.baseUrl + '/api/Roles/GetAllPermissions';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processGetAllPermissions(_response),
      );
    });
  }

  protected processGetAllPermissions(
    response: AxiosResponse,
  ): Promise<{ [key: string]: PermissionDto[] }> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      const _responseText = response.data.result;
      let result200: any = null;
      let resultData200 = _responseText;
      if (resultData200) {
        result200 = {} as any;
        for (let key in resultData200) {
          if (resultData200.hasOwnProperty(key))
            result200![key] = resultData200[key]
              ? resultData200[key].map((i: any) => PermissionDto.fromJS(i, _mappings))
              : [];
        }
      }
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<{ [key: string]: PermissionDto[] }>(<any>null);
  }
}

export class UserServiceProxy extends AppServiceBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(instance?: AxiosInstance) {
    super();
    if (instance) {
      this.instance = instance;
    } else {
      this.instance = this.ajax;
    }
    this.baseUrl = '';
  }

  /**
   * @param searchText (optional)
   * @param originalSearchText (optional)
   * @param selectedRole (optional)
   * @param pageNum (optional)
   * @param pageSize (optional)
   * @return Success
   */
  getAll(
    searchText: string | undefined,
    originalSearchText: string | undefined,
    order: Order,
    filter: Filter,
    selectedRole: string | undefined,
    bulkAction: BulkAction,
    pageNum: number | undefined,
    pageSize: number | undefined,
  ): Promise<PagedResultDtoOfUserDto> {
    let url_ = this.baseUrl + '/api/User/GetAll?';

    if (searchText !== undefined && searchText !== null)
      url_ += 'SearchText=' + encodeURIComponent('' + searchText) + '&';

    if (originalSearchText !== undefined && originalSearchText !== null)
      url_ += 'OriginalSearchText=' + encodeURIComponent('' + originalSearchText) + '&';
    if (order === undefined || order === null)
      throw new Error("The parameter 'order' must be defined and cannot be null.");
    else url_ += 'Order=' + encodeURIComponent('' + order) + '&';
    if (filter === undefined || filter === null)
      throw new Error("The parameter 'filter' must be defined and cannot be null.");
    else url_ += 'Filter=' + encodeURIComponent('' + filter) + '&';

    if (selectedRole !== undefined && selectedRole !== null)
      url_ += 'SelectedRole=' + encodeURIComponent('' + selectedRole) + '&';
    if (bulkAction === undefined || bulkAction === null)
      throw new Error("The parameter 'bulkAction' must be defined and cannot be null.");
    else url_ += 'BulkAction=' + encodeURIComponent('' + bulkAction) + '&';

    if (pageNum !== undefined && pageNum !== null)
      url_ += 'PageNum=' + encodeURIComponent('' + pageNum) + '&';

    if (pageSize !== undefined && pageSize !== null)
      url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processGetAll(_response),
      );
    });
  }

  protected processGetAll(response: AxiosResponse): Promise<PagedResultDtoOfUserDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      const _responseText = response.data.result;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PagedResultDtoOfUserDto.fromJS(resultData200, _mappings);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<PagedResultDtoOfUserDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  bulkAction(body: UserIndexOptionsDto | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/User/BulkAction';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processBulkAction(_response),
      );
    });
  }

  protected processBulkAction(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createUser(body: UserDto | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/User/CreateUser';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processCreateUser(_response),
      );
    });
  }

  protected processCreateUser(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getUser(id: string | undefined): Promise<UserDto> {
    let url_ = this.baseUrl + '/api/User/GetUser?';

    if (id !== undefined && id !== null) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processGetUser(_response),
      );
    });
  }

  protected processGetUser(response: AxiosResponse): Promise<UserDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      const _responseText = response.data.result;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = UserDto.fromJS(resultData200, _mappings);
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<UserDto>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UserDto | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/User/Update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processUpdate(_response),
      );
    });
  }

  protected processUpdate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: string | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/User/Delete?';

    if (id !== undefined && id !== null) url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {},
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processDelete(_response),
      );
    });
  }

  protected processDelete(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  editPassword(body: ResetUserPasswordtInput | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/User/EditPassword';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json-patch+json',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processEditPassword(_response),
      );
    });
  }

  protected processEditPassword(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data.result;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class WorkflowApiServiceProxy extends AppServiceBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(instance?: AxiosInstance) {
    super();
    if (instance) {
      this.instance = instance;
    } else {
      this.instance = this.ajax;
    }
    this.baseUrl = '';
  }

  /**
   * 尝试使用反射获取所有 工作流的JS扩展方法（IGlobalMethodProvider）
   * @return Success
   */
  listAllGlobalMethods(): Promise<GlobalMethodDto[]> {
    let url_ = this.baseUrl + '/api/WorkflowApi/ListAllGlobalMethods';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <AxiosRequestConfig>{
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.instance.request(options_).then((_response: AxiosResponse) => {
      return this.transformResult(url_, _response, (_response: AxiosResponse) =>
        this.processListAllGlobalMethods(_response),
      );
    });
  }

  protected processListAllGlobalMethods(response: AxiosResponse): Promise<GlobalMethodDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    let _mappings: { source: any; target: any }[] = [];
    if (status === 200) {
      const _responseText = response.data.result;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(GlobalMethodDto.fromJS(item, _mappings));
      }
      return result200;
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data.result;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers,
      );
    }
    return Promise.resolve<GlobalMethodDto[]>(<any>null);
  }
}

export class ConnectionConfigModel {
  configId!: string | null;
  configName!: string | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.configId = _data['configId'] !== undefined ? _data['configId'] : <any>null;
      this.configName = _data['configName'] !== undefined ? _data['configName'] : <any>null;
    }
  }

  static fromJS(data: any, _mappings?: any): ConnectionConfigModel {
    data = typeof data === 'object' ? data : {};
    return createInstance<ConnectionConfigModel>(data, _mappings, ConnectionConfigModel);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['configId'] = this.configId !== undefined ? this.configId : <any>null;
    data['configName'] = this.configName !== undefined ? this.configName : <any>null;
    return data;
  }
}

export class ContentFiledsApiModel {
  displayName!: string | null;
  fieldTypeName!: string | null;
  name!: string | null;
  settings!: any | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.displayName = _data['displayName'] !== undefined ? _data['displayName'] : <any>null;
      this.fieldTypeName =
        _data['fieldTypeName'] !== undefined ? _data['fieldTypeName'] : <any>null;
      this.name = _data['name'] !== undefined ? _data['name'] : <any>null;
      this.settings = _data['settings'] !== undefined ? _data['settings'] : <any>null;
    }
  }

  static fromJS(data: any, _mappings?: any): ContentFiledsApiModel {
    data = typeof data === 'object' ? data : {};
    return createInstance<ContentFiledsApiModel>(data, _mappings, ContentFiledsApiModel);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName !== undefined ? this.displayName : <any>null;
    data['fieldTypeName'] = this.fieldTypeName !== undefined ? this.fieldTypeName : <any>null;
    data['name'] = this.name !== undefined ? this.name : <any>null;
    data['settings'] = this.settings !== undefined ? this.settings : <any>null;
    return data;
  }
}

export class ContentItem {
  id!: number;
  contentItemId!: string | null;
  contentItemVersionId!: string | null;
  contentType!: string | null;
  published!: boolean;
  latest!: boolean;
  modifiedUtc!: Date | null;
  publishedUtc!: Date | null;
  createdUtc!: Date | null;
  owner!: string | null;
  author!: string | null;
  displayText!: string | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'] !== undefined ? _data['id'] : <any>null;
      this.contentItemId =
        _data['contentItemId'] !== undefined ? _data['contentItemId'] : <any>null;
      this.contentItemVersionId =
        _data['contentItemVersionId'] !== undefined ? _data['contentItemVersionId'] : <any>null;
      this.contentType = _data['contentType'] !== undefined ? _data['contentType'] : <any>null;
      this.published = _data['published'] !== undefined ? _data['published'] : <any>null;
      this.latest = _data['latest'] !== undefined ? _data['latest'] : <any>null;
      this.modifiedUtc = _data['modifiedUtc']
        ? new Date(_data['modifiedUtc'].toString())
        : <any>null;
      this.publishedUtc = _data['publishedUtc']
        ? new Date(_data['publishedUtc'].toString())
        : <any>null;
      this.createdUtc = _data['createdUtc'] ? new Date(_data['createdUtc'].toString()) : <any>null;
      this.owner = _data['owner'] !== undefined ? _data['owner'] : <any>null;
      this.author = _data['author'] !== undefined ? _data['author'] : <any>null;
      this.displayText = _data['displayText'] !== undefined ? _data['displayText'] : <any>null;
    }
  }

  static fromJS(data: any, _mappings?: any): ContentItem {
    data = typeof data === 'object' ? data : {};
    return createInstance<ContentItem>(data, _mappings, ContentItem);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id !== undefined ? this.id : <any>null;
    data['contentItemId'] = this.contentItemId !== undefined ? this.contentItemId : <any>null;
    data['contentItemVersionId'] =
      this.contentItemVersionId !== undefined ? this.contentItemVersionId : <any>null;
    data['contentType'] = this.contentType !== undefined ? this.contentType : <any>null;
    data['published'] = this.published !== undefined ? this.published : <any>null;
    data['latest'] = this.latest !== undefined ? this.latest : <any>null;
    data['modifiedUtc'] = this.modifiedUtc ? this.modifiedUtc.toISOString() : <any>null;
    data['publishedUtc'] = this.publishedUtc ? this.publishedUtc.toISOString() : <any>null;
    data['createdUtc'] = this.createdUtc ? this.createdUtc.toISOString() : <any>null;
    data['owner'] = this.owner !== undefined ? this.owner : <any>null;
    data['author'] = this.author !== undefined ? this.author : <any>null;
    data['displayText'] = this.displayText !== undefined ? this.displayText : <any>null;
    return data;
  }
}

export class ContentPartApiModel {
  fields!: ContentFiledsApiModel[] | null;
  name!: string | null;
  settings!: any | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      if (Array.isArray(_data['fields'])) {
        this.fields = [] as any;
        for (let item of _data['fields'])
          this.fields!.push(ContentFiledsApiModel.fromJS(item, _mappings));
      }
      this.name = _data['name'] !== undefined ? _data['name'] : <any>null;
      this.settings = _data['settings'] !== undefined ? _data['settings'] : <any>null;
    }
  }

  static fromJS(data: any, _mappings?: any): ContentPartApiModel {
    data = typeof data === 'object' ? data : {};
    return createInstance<ContentPartApiModel>(data, _mappings, ContentPartApiModel);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.fields)) {
      data['fields'] = [];
      for (let item of this.fields) data['fields'].push(item.toJSON());
    }
    data['name'] = this.name !== undefined ? this.name : <any>null;
    data['settings'] = this.settings !== undefined ? this.settings : <any>null;
    return data;
  }
}

export class ContentTypeApiModel {
  displayName!: string | null;
  parts!: ContentPartApiModel[] | null;
  name!: string | null;
  settings!: any | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.displayName = _data['displayName'] !== undefined ? _data['displayName'] : <any>null;
      if (Array.isArray(_data['parts'])) {
        this.parts = [] as any;
        for (let item of _data['parts'])
          this.parts!.push(ContentPartApiModel.fromJS(item, _mappings));
      }
      this.name = _data['name'] !== undefined ? _data['name'] : <any>null;
      this.settings = _data['settings'] !== undefined ? _data['settings'] : <any>null;
    }
  }

  static fromJS(data: any, _mappings?: any): ContentTypeApiModel {
    data = typeof data === 'object' ? data : {};
    return createInstance<ContentTypeApiModel>(data, _mappings, ContentTypeApiModel);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['displayName'] = this.displayName !== undefined ? this.displayName : <any>null;
    if (Array.isArray(this.parts)) {
      data['parts'] = [];
      for (let item of this.parts) data['parts'].push(item.toJSON());
    }
    data['name'] = this.name !== undefined ? this.name : <any>null;
    data['settings'] = this.settings !== undefined ? this.settings : <any>null;
    return data;
  }
}

export class CreateApiViewModel {
  description!: string | null;
  name!: string;
  databaseProvider!: string | null;
  requestUrlPrefix!: string | null;
  requestUrlHost!: string | null;
  connectionString!: string | null;
  tablePrefix!: string | null;
  recipeName!: string | null;
  featureProfile!: string | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.description = _data['description'] !== undefined ? _data['description'] : <any>null;
      this.name = _data['name'] !== undefined ? _data['name'] : <any>null;
      this.databaseProvider =
        _data['databaseProvider'] !== undefined ? _data['databaseProvider'] : <any>null;
      this.requestUrlPrefix =
        _data['requestUrlPrefix'] !== undefined ? _data['requestUrlPrefix'] : <any>null;
      this.requestUrlHost =
        _data['requestUrlHost'] !== undefined ? _data['requestUrlHost'] : <any>null;
      this.connectionString =
        _data['connectionString'] !== undefined ? _data['connectionString'] : <any>null;
      this.tablePrefix = _data['tablePrefix'] !== undefined ? _data['tablePrefix'] : <any>null;
      this.recipeName = _data['recipeName'] !== undefined ? _data['recipeName'] : <any>null;
      this.featureProfile =
        _data['featureProfile'] !== undefined ? _data['featureProfile'] : <any>null;
    }
  }

  static fromJS(data: any, _mappings?: any): CreateApiViewModel {
    data = typeof data === 'object' ? data : {};
    return createInstance<CreateApiViewModel>(data, _mappings, CreateApiViewModel);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['description'] = this.description !== undefined ? this.description : <any>null;
    data['name'] = this.name !== undefined ? this.name : <any>null;
    data['databaseProvider'] =
      this.databaseProvider !== undefined ? this.databaseProvider : <any>null;
    data['requestUrlPrefix'] =
      this.requestUrlPrefix !== undefined ? this.requestUrlPrefix : <any>null;
    data['requestUrlHost'] = this.requestUrlHost !== undefined ? this.requestUrlHost : <any>null;
    data['connectionString'] =
      this.connectionString !== undefined ? this.connectionString : <any>null;
    data['tablePrefix'] = this.tablePrefix !== undefined ? this.tablePrefix : <any>null;
    data['recipeName'] = this.recipeName !== undefined ? this.recipeName : <any>null;
    data['featureProfile'] = this.featureProfile !== undefined ? this.featureProfile : <any>null;
    return data;
  }
}

export class DbColumnInfoDto {
  name!: string | null;
  csType!: TypeDto;
  dbType!: number;
  dbTypeText!: string | null;
  dbTypeTextFull!: string | null;
  maxLength!: number;
  isPrimary!: boolean;
  isIdentity!: boolean;
  isNullable!: boolean;
  coment!: string | null;
  defaultValue!: string | null;
  position!: number;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.name = _data['name'] !== undefined ? _data['name'] : <any>null;
      this.csType = _data['csType'] ? TypeDto.fromJS(_data['csType'], _mappings) : <any>null;
      this.dbType = _data['dbType'] !== undefined ? _data['dbType'] : <any>null;
      this.dbTypeText = _data['dbTypeText'] !== undefined ? _data['dbTypeText'] : <any>null;
      this.dbTypeTextFull =
        _data['dbTypeTextFull'] !== undefined ? _data['dbTypeTextFull'] : <any>null;
      this.maxLength = _data['maxLength'] !== undefined ? _data['maxLength'] : <any>null;
      this.isPrimary = _data['isPrimary'] !== undefined ? _data['isPrimary'] : <any>null;
      this.isIdentity = _data['isIdentity'] !== undefined ? _data['isIdentity'] : <any>null;
      this.isNullable = _data['isNullable'] !== undefined ? _data['isNullable'] : <any>null;
      this.coment = _data['coment'] !== undefined ? _data['coment'] : <any>null;
      this.defaultValue = _data['defaultValue'] !== undefined ? _data['defaultValue'] : <any>null;
      this.position = _data['position'] !== undefined ? _data['position'] : <any>null;
    }
  }

  static fromJS(data: any, _mappings?: any): DbColumnInfoDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<DbColumnInfoDto>(data, _mappings, DbColumnInfoDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name !== undefined ? this.name : <any>null;
    data['csType'] = this.csType ? this.csType.toJSON() : <any>null;
    data['dbType'] = this.dbType !== undefined ? this.dbType : <any>null;
    data['dbTypeText'] = this.dbTypeText !== undefined ? this.dbTypeText : <any>null;
    data['dbTypeTextFull'] = this.dbTypeTextFull !== undefined ? this.dbTypeTextFull : <any>null;
    data['maxLength'] = this.maxLength !== undefined ? this.maxLength : <any>null;
    data['isPrimary'] = this.isPrimary !== undefined ? this.isPrimary : <any>null;
    data['isIdentity'] = this.isIdentity !== undefined ? this.isIdentity : <any>null;
    data['isNullable'] = this.isNullable !== undefined ? this.isNullable : <any>null;
    data['coment'] = this.coment !== undefined ? this.coment : <any>null;
    data['defaultValue'] = this.defaultValue !== undefined ? this.defaultValue : <any>null;
    data['position'] = this.position !== undefined ? this.position : <any>null;
    return data;
  }
}

export class DbTableInfoDto {
  id!: string | null;
  columnsCount!: number;
  schema!: string | null;
  name!: string | null;
  comment!: string | null;
  type!: string | null;
  columns!: DbColumnInfoDto[] | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'] !== undefined ? _data['id'] : <any>null;
      this.columnsCount = _data['columnsCount'] !== undefined ? _data['columnsCount'] : <any>null;
      this.schema = _data['schema'] !== undefined ? _data['schema'] : <any>null;
      this.name = _data['name'] !== undefined ? _data['name'] : <any>null;
      this.comment = _data['comment'] !== undefined ? _data['comment'] : <any>null;
      this.type = _data['type'] !== undefined ? _data['type'] : <any>null;
      if (Array.isArray(_data['columns'])) {
        this.columns = [] as any;
        for (let item of _data['columns'])
          this.columns!.push(DbColumnInfoDto.fromJS(item, _mappings));
      }
    }
  }

  static fromJS(data: any, _mappings?: any): DbTableInfoDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<DbTableInfoDto>(data, _mappings, DbTableInfoDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id !== undefined ? this.id : <any>null;
    data['columnsCount'] = this.columnsCount !== undefined ? this.columnsCount : <any>null;
    data['schema'] = this.schema !== undefined ? this.schema : <any>null;
    data['name'] = this.name !== undefined ? this.name : <any>null;
    data['comment'] = this.comment !== undefined ? this.comment : <any>null;
    data['type'] = this.type !== undefined ? this.type : <any>null;
    if (Array.isArray(this.columns)) {
      data['columns'] = [];
      for (let item of this.columns) data['columns'].push(item.toJSON());
    }
    return data;
  }
}

export class GlobalMethodDto {
  name!: string | null;
  description!: string | null;
  parameters!: any[] | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.name = _data['name'] !== undefined ? _data['name'] : <any>null;
      this.description = _data['description'] !== undefined ? _data['description'] : <any>null;
      if (Array.isArray(_data['parameters'])) {
        this.parameters = [] as any;
        for (let item of _data['parameters']) this.parameters!.push(item);
      }
    }
  }

  static fromJS(data: any, _mappings?: any): GlobalMethodDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<GlobalMethodDto>(data, _mappings, GlobalMethodDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name !== undefined ? this.name : <any>null;
    data['description'] = this.description !== undefined ? this.description : <any>null;
    if (Array.isArray(this.parameters)) {
      data['parameters'] = [];
      for (let item of this.parameters) data['parameters'].push(item);
    }
    return data;
  }
}

export class ImportJsonInupt {
  json!: string | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.json = _data['json'] !== undefined ? _data['json'] : <any>null;
    }
  }

  static fromJS(data: any, _mappings?: any): ImportJsonInupt {
    data = typeof data === 'object' ? data : {};
    return createInstance<ImportJsonInupt>(data, _mappings, ImportJsonInupt);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['json'] = this.json !== undefined ? this.json : <any>null;
    return data;
  }
}

export class LuceneQueryModel {
  indexName!: string | null;
  query!: string | null;
  parameters!: string | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.indexName = _data['indexName'] !== undefined ? _data['indexName'] : <any>null;
      this.query = _data['query'] !== undefined ? _data['query'] : <any>null;
      this.parameters = _data['parameters'] !== undefined ? _data['parameters'] : <any>null;
    }
  }

  static fromJS(data: any, _mappings?: any): LuceneQueryModel {
    data = typeof data === 'object' ? data : {};
    return createInstance<LuceneQueryModel>(data, _mappings, LuceneQueryModel);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['indexName'] = this.indexName !== undefined ? this.indexName : <any>null;
    data['query'] = this.query !== undefined ? this.query : <any>null;
    data['parameters'] = this.parameters !== undefined ? this.parameters : <any>null;
    return data;
  }
}

export class OrchardCoreBaseField {
  name!: string | null;
  description!: string | null;
  valuePath!: string | null;
  defaultMappToCsType!: string[] | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.name = _data['name'] !== undefined ? _data['name'] : <any>null;
      this.description = _data['description'] !== undefined ? _data['description'] : <any>null;
      this.valuePath = _data['valuePath'] !== undefined ? _data['valuePath'] : <any>null;
      if (Array.isArray(_data['defaultMappToCsType'])) {
        this.defaultMappToCsType = [] as any;
        for (let item of _data['defaultMappToCsType']) this.defaultMappToCsType!.push(item);
      }
    }
  }

  static fromJS(data: any, _mappings?: any): OrchardCoreBaseField {
    data = typeof data === 'object' ? data : {};
    return createInstance<OrchardCoreBaseField>(data, _mappings, OrchardCoreBaseField);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name !== undefined ? this.name : <any>null;
    data['description'] = this.description !== undefined ? this.description : <any>null;
    data['valuePath'] = this.valuePath !== undefined ? this.valuePath : <any>null;
    if (Array.isArray(this.defaultMappToCsType)) {
      data['defaultMappToCsType'] = [];
      for (let item of this.defaultMappToCsType) data['defaultMappToCsType'].push(item);
    }
    return data;
  }
}

export class PagedResultDtoOfUserDto {
  total!: number;
  items!: UserDto[] | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.total = _data['total'] !== undefined ? _data['total'] : <any>null;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(UserDto.fromJS(item, _mappings));
      }
    }
  }

  static fromJS(data: any, _mappings?: any): PagedResultDtoOfUserDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<PagedResultDtoOfUserDto>(data, _mappings, PagedResultDtoOfUserDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['total'] = this.total !== undefined ? this.total : <any>null;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export class PermissionDto {
  readonly name!: string | null;
  description!: string | null;
  category!: string | null;
  readonly impliedBy!: PermissionDto[] | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      (<any>this).name = _data['name'] !== undefined ? _data['name'] : <any>null;
      this.description = _data['description'] !== undefined ? _data['description'] : <any>null;
      this.category = _data['category'] !== undefined ? _data['category'] : <any>null;
      if (Array.isArray(_data['impliedBy'])) {
        (<any>this).impliedBy = [] as any;
        for (let item of _data['impliedBy'])
          (<any>this).impliedBy!.push(PermissionDto.fromJS(item, _mappings));
      }
    }
  }

  static fromJS(data: any, _mappings?: any): PermissionDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<PermissionDto>(data, _mappings, PermissionDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name !== undefined ? this.name : <any>null;
    data['description'] = this.description !== undefined ? this.description : <any>null;
    data['category'] = this.category !== undefined ? this.category : <any>null;
    if (Array.isArray(this.impliedBy)) {
      data['impliedBy'] = [];
      for (let item of this.impliedBy) data['impliedBy'].push(item.toJSON());
    }
    return data;
  }
}

export class ResetUserPasswordtInput {
  email!: string | null;
  newPassword!: string | null;
  passwordConfirmation!: string | null;
  resetToken!: string | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.email = _data['email'] !== undefined ? _data['email'] : <any>null;
      this.newPassword = _data['newPassword'] !== undefined ? _data['newPassword'] : <any>null;
      this.passwordConfirmation =
        _data['passwordConfirmation'] !== undefined ? _data['passwordConfirmation'] : <any>null;
      this.resetToken = _data['resetToken'] !== undefined ? _data['resetToken'] : <any>null;
    }
  }

  static fromJS(data: any, _mappings?: any): ResetUserPasswordtInput {
    data = typeof data === 'object' ? data : {};
    return createInstance<ResetUserPasswordtInput>(data, _mappings, ResetUserPasswordtInput);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email !== undefined ? this.email : <any>null;
    data['newPassword'] = this.newPassword !== undefined ? this.newPassword : <any>null;
    data['passwordConfirmation'] =
      this.passwordConfirmation !== undefined ? this.passwordConfirmation : <any>null;
    data['resetToken'] = this.resetToken !== undefined ? this.resetToken : <any>null;
    return data;
  }
}

export class RoleClaimDto {
  claimType!: string | null;
  claimValue!: string | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.claimType = _data['claimType'] !== undefined ? _data['claimType'] : <any>null;
      this.claimValue = _data['claimValue'] !== undefined ? _data['claimValue'] : <any>null;
    }
  }

  static fromJS(data: any, _mappings?: any): RoleClaimDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<RoleClaimDto>(data, _mappings, RoleClaimDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['claimType'] = this.claimType !== undefined ? this.claimType : <any>null;
    data['claimValue'] = this.claimValue !== undefined ? this.claimValue : <any>null;
    return data;
  }
}

export class RoleDetailsDto {
  name!: string | null;
  roleDescription!: string | null;
  roleCategoryPermissions!: { [key: string]: PermissionDto[] } | null;
  effectivePermissions!: string[] | null;
  role!: RoleDto;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.name = _data['name'] !== undefined ? _data['name'] : <any>null;
      this.roleDescription =
        _data['roleDescription'] !== undefined ? _data['roleDescription'] : <any>null;
      if (_data['roleCategoryPermissions']) {
        this.roleCategoryPermissions = {} as any;
        for (let key in _data['roleCategoryPermissions']) {
          if (_data['roleCategoryPermissions'].hasOwnProperty(key))
            this.roleCategoryPermissions![key] = _data['roleCategoryPermissions'][key]
              ? _data['roleCategoryPermissions'][key].map((i: any) =>
                  PermissionDto.fromJS(i, _mappings),
                )
              : [];
        }
      }
      if (Array.isArray(_data['effectivePermissions'])) {
        this.effectivePermissions = [] as any;
        for (let item of _data['effectivePermissions']) this.effectivePermissions!.push(item);
      }
      this.role = _data['role'] ? RoleDto.fromJS(_data['role'], _mappings) : <any>null;
    }
  }

  static fromJS(data: any, _mappings?: any): RoleDetailsDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<RoleDetailsDto>(data, _mappings, RoleDetailsDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name !== undefined ? this.name : <any>null;
    data['roleDescription'] = this.roleDescription !== undefined ? this.roleDescription : <any>null;
    if (this.roleCategoryPermissions) {
      data['roleCategoryPermissions'] = {};
      for (let key in this.roleCategoryPermissions) {
        if (this.roleCategoryPermissions.hasOwnProperty(key))
          data['roleCategoryPermissions'][key] =
            this.roleCategoryPermissions[key] !== undefined
              ? this.roleCategoryPermissions[key]
              : <any>null;
      }
    }
    if (Array.isArray(this.effectivePermissions)) {
      data['effectivePermissions'] = [];
      for (let item of this.effectivePermissions) data['effectivePermissions'].push(item);
    }
    data['role'] = this.role ? this.role.toJSON() : <any>null;
    return data;
  }
}

export class RoleDto {
  roleName!: string | null;
  roleDescription!: string | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.roleName = _data['roleName'] !== undefined ? _data['roleName'] : <any>null;
      this.roleDescription =
        _data['roleDescription'] !== undefined ? _data['roleDescription'] : <any>null;
    }
  }

  static fromJS(data: any, _mappings?: any): RoleDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<RoleDto>(data, _mappings, RoleDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['roleName'] = this.roleName !== undefined ? this.roleName : <any>null;
    data['roleDescription'] = this.roleDescription !== undefined ? this.roleDescription : <any>null;
    return data;
  }
}

export class SelectListGroup {
  disabled!: boolean;
  name!: string | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.disabled = _data['disabled'] !== undefined ? _data['disabled'] : <any>null;
      this.name = _data['name'] !== undefined ? _data['name'] : <any>null;
    }
  }

  static fromJS(data: any, _mappings?: any): SelectListGroup {
    data = typeof data === 'object' ? data : {};
    return createInstance<SelectListGroup>(data, _mappings, SelectListGroup);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['disabled'] = this.disabled !== undefined ? this.disabled : <any>null;
    data['name'] = this.name !== undefined ? this.name : <any>null;
    return data;
  }
}

export class SelectListItem {
  disabled!: boolean;
  group!: SelectListGroup;
  selected!: boolean;
  text!: string | null;
  value!: string | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.disabled = _data['disabled'] !== undefined ? _data['disabled'] : <any>null;
      this.group = _data['group'] ? SelectListGroup.fromJS(_data['group'], _mappings) : <any>null;
      this.selected = _data['selected'] !== undefined ? _data['selected'] : <any>null;
      this.text = _data['text'] !== undefined ? _data['text'] : <any>null;
      this.value = _data['value'] !== undefined ? _data['value'] : <any>null;
    }
  }

  static fromJS(data: any, _mappings?: any): SelectListItem {
    data = typeof data === 'object' ? data : {};
    return createInstance<SelectListItem>(data, _mappings, SelectListItem);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['disabled'] = this.disabled !== undefined ? this.disabled : <any>null;
    data['group'] = this.group ? this.group.toJSON() : <any>null;
    data['selected'] = this.selected !== undefined ? this.selected : <any>null;
    data['text'] = this.text !== undefined ? this.text : <any>null;
    data['value'] = this.value !== undefined ? this.value : <any>null;
    return data;
  }
}

export class SetupApiViewModel {
  name!: string;
  siteName!: string;
  databaseProvider!: string | null;
  connectionString!: string | null;
  tablePrefix!: string | null;
  userName!: string;
  email!: string;
  password!: string | null;
  recipeName!: string | null;
  recipe!: string | null;
  siteTimeZone!: string | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.name = _data['name'] !== undefined ? _data['name'] : <any>null;
      this.siteName = _data['siteName'] !== undefined ? _data['siteName'] : <any>null;
      this.databaseProvider =
        _data['databaseProvider'] !== undefined ? _data['databaseProvider'] : <any>null;
      this.connectionString =
        _data['connectionString'] !== undefined ? _data['connectionString'] : <any>null;
      this.tablePrefix = _data['tablePrefix'] !== undefined ? _data['tablePrefix'] : <any>null;
      this.userName = _data['userName'] !== undefined ? _data['userName'] : <any>null;
      this.email = _data['email'] !== undefined ? _data['email'] : <any>null;
      this.password = _data['password'] !== undefined ? _data['password'] : <any>null;
      this.recipeName = _data['recipeName'] !== undefined ? _data['recipeName'] : <any>null;
      this.recipe = _data['recipe'] !== undefined ? _data['recipe'] : <any>null;
      this.siteTimeZone = _data['siteTimeZone'] !== undefined ? _data['siteTimeZone'] : <any>null;
    }
  }

  static fromJS(data: any, _mappings?: any): SetupApiViewModel {
    data = typeof data === 'object' ? data : {};
    return createInstance<SetupApiViewModel>(data, _mappings, SetupApiViewModel);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name !== undefined ? this.name : <any>null;
    data['siteName'] = this.siteName !== undefined ? this.siteName : <any>null;
    data['databaseProvider'] =
      this.databaseProvider !== undefined ? this.databaseProvider : <any>null;
    data['connectionString'] =
      this.connectionString !== undefined ? this.connectionString : <any>null;
    data['tablePrefix'] = this.tablePrefix !== undefined ? this.tablePrefix : <any>null;
    data['userName'] = this.userName !== undefined ? this.userName : <any>null;
    data['email'] = this.email !== undefined ? this.email : <any>null;
    data['password'] = this.password !== undefined ? this.password : <any>null;
    data['recipeName'] = this.recipeName !== undefined ? this.recipeName : <any>null;
    data['recipe'] = this.recipe !== undefined ? this.recipe : <any>null;
    data['siteTimeZone'] = this.siteTimeZone !== undefined ? this.siteTimeZone : <any>null;
    return data;
  }
}

export class TypeDto {
  name!: string | null;
  fullName!: string | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.name = _data['name'] !== undefined ? _data['name'] : <any>null;
      this.fullName = _data['fullName'] !== undefined ? _data['fullName'] : <any>null;
    }
  }

  static fromJS(data: any, _mappings?: any): TypeDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<TypeDto>(data, _mappings, TypeDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name !== undefined ? this.name : <any>null;
    data['fullName'] = this.fullName !== undefined ? this.fullName : <any>null;
    return data;
  }
}

export class UpdateRoleInput {
  roleName!: string | null;
  roleDescription!: string | null;
  normalizedRoleName!: string | null;
  roleClaims!: RoleClaimDto[] | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.roleName = _data['roleName'] !== undefined ? _data['roleName'] : <any>null;
      this.roleDescription =
        _data['roleDescription'] !== undefined ? _data['roleDescription'] : <any>null;
      this.normalizedRoleName =
        _data['normalizedRoleName'] !== undefined ? _data['normalizedRoleName'] : <any>null;
      if (Array.isArray(_data['roleClaims'])) {
        this.roleClaims = [] as any;
        for (let item of _data['roleClaims'])
          this.roleClaims!.push(RoleClaimDto.fromJS(item, _mappings));
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UpdateRoleInput {
    data = typeof data === 'object' ? data : {};
    return createInstance<UpdateRoleInput>(data, _mappings, UpdateRoleInput);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['roleName'] = this.roleName !== undefined ? this.roleName : <any>null;
    data['roleDescription'] = this.roleDescription !== undefined ? this.roleDescription : <any>null;
    data['normalizedRoleName'] =
      this.normalizedRoleName !== undefined ? this.normalizedRoleName : <any>null;
    if (Array.isArray(this.roleClaims)) {
      data['roleClaims'] = [];
      for (let item of this.roleClaims) data['roleClaims'].push(item.toJSON());
    }
    return data;
  }
}

export class UserClaim {
  claimType!: string | null;
  claimValue!: string | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.claimType = _data['claimType'] !== undefined ? _data['claimType'] : <any>null;
      this.claimValue = _data['claimValue'] !== undefined ? _data['claimValue'] : <any>null;
    }
  }

  static fromJS(data: any, _mappings?: any): UserClaim {
    data = typeof data === 'object' ? data : {};
    return createInstance<UserClaim>(data, _mappings, UserClaim);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['claimType'] = this.claimType !== undefined ? this.claimType : <any>null;
    data['claimValue'] = this.claimValue !== undefined ? this.claimValue : <any>null;
    return data;
  }
}

export class UserDto {
  id!: number | null;
  userId!: string | null;
  userName!: string | null;
  normalizedUserName!: string | null;
  email!: string | null;
  normalizedEmail!: string | null;
  passwordHash!: string | null;
  securityStamp!: string | null;
  emailConfirmed!: boolean;
  isEnabled!: boolean;
  isLockoutEnabled!: boolean;
  lockoutEndUtc!: Date | null;
  accessFailedCount!: number;
  roleNames!: string[] | null;
  userClaims!: UserClaim[] | null;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.id = _data['id'] !== undefined ? _data['id'] : <any>null;
      this.userId = _data['userId'] !== undefined ? _data['userId'] : <any>null;
      this.userName = _data['userName'] !== undefined ? _data['userName'] : <any>null;
      this.normalizedUserName =
        _data['normalizedUserName'] !== undefined ? _data['normalizedUserName'] : <any>null;
      this.email = _data['email'] !== undefined ? _data['email'] : <any>null;
      this.normalizedEmail =
        _data['normalizedEmail'] !== undefined ? _data['normalizedEmail'] : <any>null;
      this.passwordHash = _data['passwordHash'] !== undefined ? _data['passwordHash'] : <any>null;
      this.securityStamp =
        _data['securityStamp'] !== undefined ? _data['securityStamp'] : <any>null;
      this.emailConfirmed =
        _data['emailConfirmed'] !== undefined ? _data['emailConfirmed'] : <any>null;
      this.isEnabled = _data['isEnabled'] !== undefined ? _data['isEnabled'] : <any>null;
      this.isLockoutEnabled =
        _data['isLockoutEnabled'] !== undefined ? _data['isLockoutEnabled'] : <any>null;
      this.lockoutEndUtc = _data['lockoutEndUtc']
        ? new Date(_data['lockoutEndUtc'].toString())
        : <any>null;
      this.accessFailedCount =
        _data['accessFailedCount'] !== undefined ? _data['accessFailedCount'] : <any>null;
      if (Array.isArray(_data['roleNames'])) {
        this.roleNames = [] as any;
        for (let item of _data['roleNames']) this.roleNames!.push(item);
      }
      if (Array.isArray(_data['userClaims'])) {
        this.userClaims = [] as any;
        for (let item of _data['userClaims'])
          this.userClaims!.push(UserClaim.fromJS(item, _mappings));
      }
    }
  }

  static fromJS(data: any, _mappings?: any): UserDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<UserDto>(data, _mappings, UserDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id !== undefined ? this.id : <any>null;
    data['userId'] = this.userId !== undefined ? this.userId : <any>null;
    data['userName'] = this.userName !== undefined ? this.userName : <any>null;
    data['normalizedUserName'] =
      this.normalizedUserName !== undefined ? this.normalizedUserName : <any>null;
    data['email'] = this.email !== undefined ? this.email : <any>null;
    data['normalizedEmail'] = this.normalizedEmail !== undefined ? this.normalizedEmail : <any>null;
    data['passwordHash'] = this.passwordHash !== undefined ? this.passwordHash : <any>null;
    data['securityStamp'] = this.securityStamp !== undefined ? this.securityStamp : <any>null;
    data['emailConfirmed'] = this.emailConfirmed !== undefined ? this.emailConfirmed : <any>null;
    data['isEnabled'] = this.isEnabled !== undefined ? this.isEnabled : <any>null;
    data['isLockoutEnabled'] =
      this.isLockoutEnabled !== undefined ? this.isLockoutEnabled : <any>null;
    data['lockoutEndUtc'] = this.lockoutEndUtc ? this.lockoutEndUtc.toISOString() : <any>null;
    data['accessFailedCount'] =
      this.accessFailedCount !== undefined ? this.accessFailedCount : <any>null;
    if (Array.isArray(this.roleNames)) {
      data['roleNames'] = [];
      for (let item of this.roleNames) data['roleNames'].push(item);
    }
    if (Array.isArray(this.userClaims)) {
      data['userClaims'] = [];
      for (let item of this.userClaims) data['userClaims'].push(item.toJSON());
    }
    return data;
  }
}

export class UserIndexOptionsDto {
  searchText!: string | null;
  originalSearchText!: string | null;
  order!: UserIndexOptionsDtoOrder;
  filter!: UserIndexOptionsDtoFilter;
  selectedRole!: string | null;
  bulkAction!: UserIndexOptionsDtoBulkAction;

  init(_data?: any, _mappings?: any) {
    if (_data) {
      this.searchText = _data['searchText'] !== undefined ? _data['searchText'] : <any>null;
      this.originalSearchText =
        _data['originalSearchText'] !== undefined ? _data['originalSearchText'] : <any>null;
      this.order = _data['order'] !== undefined ? _data['order'] : <any>null;
      this.filter = _data['filter'] !== undefined ? _data['filter'] : <any>null;
      this.selectedRole = _data['selectedRole'] !== undefined ? _data['selectedRole'] : <any>null;
      this.bulkAction = _data['bulkAction'] !== undefined ? _data['bulkAction'] : <any>null;
    }
  }

  static fromJS(data: any, _mappings?: any): UserIndexOptionsDto {
    data = typeof data === 'object' ? data : {};
    return createInstance<UserIndexOptionsDto>(data, _mappings, UserIndexOptionsDto);
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['searchText'] = this.searchText !== undefined ? this.searchText : <any>null;
    data['originalSearchText'] =
      this.originalSearchText !== undefined ? this.originalSearchText : <any>null;
    data['order'] = this.order !== undefined ? this.order : <any>null;
    data['filter'] = this.filter !== undefined ? this.filter : <any>null;
    data['selectedRole'] = this.selectedRole !== undefined ? this.selectedRole : <any>null;
    data['bulkAction'] = this.bulkAction !== undefined ? this.bulkAction : <any>null;
    return data;
  }
}

export enum SyncMappingDeriction {
  OrchardCoreToRDBMS = 0,
  RDBMSToOrchardCore = 1,
  TwoWay = 2,
}

export enum Order {
  Name = 0,
  Email = 1,
}

export enum Filter {
  All = 0,
  Approved = 1,
  Pending = 2,
  EmailPending = 3,
  Enabled = 4,
  Disabled = 5,
}

export enum BulkAction {
  None = 0,
  Delete = 1,
  Enable = 2,
  Disable = 3,
  Approve = 4,
  ChallengeEmail = 5,
}

export enum UserIndexOptionsDtoOrder {
  Name = 0,
  Email = 1,
}

export enum UserIndexOptionsDtoFilter {
  All = 0,
  Approved = 1,
  Pending = 2,
  EmailPending = 3,
  Enabled = 4,
  Disabled = 5,
}

export enum UserIndexOptionsDtoBulkAction {
  None = 0,
  Delete = 1,
  Enable = 2,
  Disable = 3,
  Approve = 4,
  ChallengeEmail = 5,
}

function jsonParse(json: any, reviver?: any) {
  json = JSON.parse(json, reviver);

  var byid: any = {};
  var refs: any = [];
  json = (function recurse(obj: any, prop?: any, parent?: any) {
    if (typeof obj !== 'object' || !obj) return obj;

    if ('$ref' in obj) {
      let ref = obj.$ref;
      if (ref in byid) return byid[ref];
      refs.push([parent, prop, ref]);
      return undefined;
    } else if ('$id' in obj) {
      let id = obj.$id;
      delete obj.$id;
      if ('$values' in obj) obj = obj.$values;
      byid[id] = obj;
    }

    if (Array.isArray(obj)) {
      obj = obj.map((v, i) => recurse(v, i, obj));
    } else {
      for (var p in obj) {
        if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
          obj[p] = recurse(obj[p], p, obj);
      }
    }

    return obj;
  })(json);

  for (let i = 0; i < refs.length; i++) {
    const ref = refs[i];
    ref[0][ref[1]] = byid[ref[2]];
  }

  return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T {
  if (!mappings) mappings = [];
  else {
    let mapping = mappings.filter((m: any) => m.source === data);
    if (mapping.length === 1) return <T>mapping[0].target;
  }

  let result: any = new type();
  mappings.push({ source: data, target: result });
  result.init(data, mappings);
  return result;
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any,
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any,
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}
